#pragma config(UART_Usage, UART1, User_Control)
#pragma config(UART_Usage, UART2, CMU_Camera)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//////////////////////////////////////////////////////////////////////////////////////////////
//
//                CMUCAM Operation with VEX Cortex Controllers
//
// Short program to demonstrate operation of the CMUCAM camera.
//
//////////////////////////////////////////////////////////////////////////////////////////////

#pragma platform(VEX2)

//
// Load the "configuration program" generated camera  settings
//
#include "cameraConfiguration.h"

///////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////

task main()
{
	int nTotalNumbOfPackets = 0;
  int nMSecBetweenPackets = 0;
  float nFrameRate = 0;
  int horizontal;
  int vertical;
	TTrackingDataWords myData;

	//
	// Wait for the camera to initialize.
	//
	while (true)
	{
		// Wait for the camera to begin tracking

    GetTrackingParms(myData);
    if (myData.nCameraStatus == camStatusTracking)
      break;
    wait1Msec(10);
	}

	//
	// The camera is now tracking. It can take several seconds for the camera to auto adjust white balance, gain, etc, so wait
	// a little more
	//
	wait1Msec(3000);   // Let the camera stabilize
	time1[T1] = 0;     // Reset timer

	//
	// This is the main loop. It will loop forever polling the camera for new data and acting on it.
	//
	while (true)
	{
		// Depending on how the camera has been configured, it will report new data to the robot every 30 to 100 milliseconds.
		// Whenever we get new data, we want to process it as it may be used to adjust motors and servos to follow the tracked
		// object. But generally we only want to make the adjustments once per set of data.
		//
		// Wait for camera to report new data. We only want to process (i.e. adjust motors and servos) data from the camera
		// once per data received from the camera. Here's why:
		//   1. Suppose data received from the camera indicated the color was found at coordinates (20, 25). And also suppose
		//      that we wanted to adjust the robot so that the color was in the center (0, 0) of the screen.
		//   2. The X-value of 20 indicates that the color is to the right of center. So we should adjust the motor/servo to move
		//      to the left.
		//   3. Having made an adjustment, we want to repeat (loop) the process and adjust again. But we don't want to perform
		//      another adjustment until we've received new data from the camera.
		//   4. If we immediately looped back with a new adjustment and we were using the "old" data, it would look like the
		//      color X-value wasw still 20 and our algorithm would increase the value of the motor/servo adjustment a second
		//      time for the same data.
		//
		while (true)
		{
      GetTrackingParms(myData);
			if (nTotalNumbOfPackets != myData.nTrackingPacketsRcvd)
			  break;

			// Same packet that was previously received. No processing required. We should wait until new data is received.
			wait1Msec(1); // Wait a little time so that we don't use all CPU time.
			              // This makes more CPU time available for other tasks that might be running.
		}

		// Store the coordinates of the blob detected by the camera. The center of the screen is normalized to point (0, 0)

		horizontal = myData.nHorizontal;
		vertical   = myData.nVertical ;

		// Calculate some performance measurements (Optional, for info only)

		nTotalNumbOfPackets = myData.nTrackingPacketsRcvd;
		nMSecBetweenPackets = time1[T1];
		nFrameRate = 1000 / (float) nMSecBetweenPackets;
		time1[T1] = 0;   // Reset timer
	}
}
