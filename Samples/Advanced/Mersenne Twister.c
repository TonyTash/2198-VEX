//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*----------------------------------------------------------------------------------------------------*\
|*                                       - Mersenne Twister -                                         *|
|*                                     ROBOTC on VEX 2.0 CORTEX                                       *|
|*                                                                                                    *|
|*  This program uses the Mersenne Twister algorithm, developed in 1997 by Makoto Matsumoto and       *|
|*  Takuji Nishimura.                                                                                 *|
|*  The real algorithm uses 32-bit integers, but ROBTOC only supports 16-bit integers.                *|
|*                                                                                                    *|
|*                                        ROBOT CONFIGURATION                                         *|
|*    NOTES:                                                                                          *|
|*    1)  Connect the VEX LCD to UART Port 2.                                                         *|
|*                                                                                                    *|
|*    MOTORS & SENSORS:                                                                               *|
|*    [I/O Port]              [Name]              [Type]              [Description]                   *|
|*    Port 1                  none                TETRIX Controller   TETRIX                          *|
|*    Port 1 - Motor 1        motorD              12V                 Right motor                     *|
|*    Port 1 - Motor 2        motorE              12V                 Left motor                      *|
|*    Port 4                  sonarSensor         Sonar Sensor        Front mounted, front facing     *|
\*-----------------------------------------------------------------------------------------------4246-*/

long MT[624];
int index = 0;
long y;

void initGenerator(long i_seed);
void generateNumbers();
long extractNumber();


//+++++++++++++++++++++++++++++++++++++++++++++| MAIN |+++++++++++++++++++++++++++++++++++++++++++++++
task main()
{
  // initialize generator
  long mt_seed = nSysTime;
  initGenerator(mt_seed);

  // extract number
  long random_number = extractNumber();

  displayLCDPos(1,0);
  displayNextLCDNumber((long)random_number,0);

  while(true);
}
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


//------------------------------------| INITIALIZE GENERATOR |----------------------------------------
void initGenerator(long i_seed)
{
  MT[0] = i_seed;

  for(int i=1; i<=623; i++)
  {
    MT[i] = 0xffffffff & (1812433253 * (MT[i-1] ^ (MT[i-1] >> 30)) +1);
  }
}
//----------------------------------------------------------------------------------------------------

//---------------------------------------| GENERATE NUMBERS |-----------------------------------------
void generateNumbers()
{
  for(int i=0; i<=623; ++i)
  {
    y = ((MT[i] & 0x80000001) >> 31)  // take 32nd bit
      + (MT[(i+1)%624] & 0x8fffffff); // AND with last 31 bits

    if((y%2) == 1)  // y is ODD
    {
      MT[i] = MT[(i+397) % 624] ^ (y >> 1);
    }
    else            // y is EVEN
    {
      MT[i] = MT[(i+397) % 624] ^ (y >> 1) ^ 0x9908b0df;
    }
    index = 0;
  }
}
//----------------------------------------------------------------------------------------------------

//----------------------------------------| EXTRACT NUMBER |------------------------------------------
long extractNumber()
{
  if(index >= 624)
  {
    generateNumbers();
  }

  y = MT[index];
  y ^= (y >> 11);
  y ^= ((y << 7) & 0x9d2c5680);
  y ^= ((y << 15) & 0xefc60000);
  y ^= (y >> 18);

  ++index;

  return y;
}
//----------------------------------------------------------------------------------------------------
