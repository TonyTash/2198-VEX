#pragma config(UART_Usage, UART1, VEX_2x16_LCD, baudRate1200, IOPins, None, None)
#pragma config(Sensor, in4,    ,                    sensorLineFollower)
#pragma config(Sensor, dgtl1,  left,                sensorTouch)
#pragma config(Sensor, dgtl2,  middle,              sensorTouch)
#pragma config(Sensor, dgtl3,  right,               sensorTouch)
#pragma config(Sensor, dgtl4,  ,                    sensorTouch)
#pragma config(Sensor, dgtl5,  ,                    sensorTouch)
#pragma config(Sensor, dgtl6,  ,                    sensorTouch)
#pragma config(Sensor, dgtl7,  ,                    sensorTouch)
#pragma config(Sensor, dgtl8,  ,                    sensorTouch)
#pragma config(Sensor, dgtl9,  ,                    sensorTouch)
#pragma config(Sensor, dgtl10, ,                    sensorSONAR_cm)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                             Test Execution Speed
//
// This program is used to test the execution speed of the NXT brick.
//
// The basic methodology is to:
//  [1] measure the time to loop 10,000 times through an empty 'for' loop.
//  [2] measure the time to loop 10,000 times through an 'for' loop containing
//      10 identical statements.
//  [3] Take the time difference between the two loops to find the time to
//      execute 100,000 statements.
//  [4] Interpret to determine the number of microseconds per statement.
//
// To see the results of this test you should have the "Global Variables" debugger window open.
// The array 'nElapsedTime' will show the time taken to execute in microseconds a selection of
// different ROBOTC opcodes.
//
////////////////////////////////////////////////////////////////////////////////////////////////////////


const int kNumberOfLoops = 10000; // 10K x 10 instructions per loop = 100K instructions

#define testSensorType sensorTouch
const TTimers  executionTimer = T1;

#undef useLongs
#undef useFloats
#define useLongs
#define useFloats


typedef enum
{
	typeIdleLoop,
	typeAlive,

	typeIntegerAssignConstant,
	typeIntegerAddConstant,
	typeIntegerAssignVariable,
	typeIntegerAssignIndexed,
	typeIntegerAddVariable,
	typeIntegerAssignSensor,

#if defined(NXT) || defined(TETRIX)
	typeClearScreen,
	typeClearPixel,
	typeRectangleDraw,
	typeRectangleErase,
	typeRectangleFill,
	//typeIOMapRead,
#endif

	typeLongAssignConstant,
	typeLongAssignVariable,
	typeLongAssignIndexed,
	typeLongAddConstant,
	typeLongAddVariable,
	typeLongTimes,
	typeFloatAssignConstant,
	typeFloatAssignVariable,
	typeFloatAddConstant,
	typeFloatAddVariable,
	typeFloatTimes,
#if defined(hasTranscendentalSupport)
  typeSine,
	typeCosine,
#endif
  typeLogical,
	typeTrinaryAdd,
	typeTrinaryAddConstant1,
	typeTrinaryAddConstant2,

	typeLast,
} TInstructions;

int index;
TInstructions testType;

#if defined(useFloats)
float nElapsedTime[(TInstructions) typeLast];
#else
int nElapsedTime[(TInstructions) typeLast];
#endif



void measureTime(const TInstructions nInstructionType)
{
  TSensorTypes nSensorType = testSensorType;
  int i;
	int j;
	int k;
#if defined(useLongs)
	long l1;
	long l2;
#endif

#if defined(useFloats)
	float idleLoopTime;
	float loopTime;
	float elapsed;
#else
	int idleLoopTime;
	int loopTime;
	int elapsed;
#endif

	float fTemp;
	short iArray[10];
	long  lArray[10];
	float fArray[10];

	const int kInitialValues = 511; // an arbitrary value

	testType = nInstructionType;
	wait1Msec(200);

	// Some variable initialization.
	//i  = random(10);
	i  = 0;
	j  = kInitialValues;
	k  = kInitialValues;
#if defined(useLongs)
	l1 = kInitialValues * 256;
	l2 = kInitialValues;
#endif
#if defined(useFloats)
	fTemp = 0.999999999;
#endif
	idleLoopTime = nElapsedTime[typeIdleLoop];

	ClearTimer(executionTimer);
	for (index = 1; index <= kNumberOfLoops; ++index)
	{
		//
		// to measure a different instruction type, simply change the
		// definition of the following constant.
		//
			//
			// Since 'nInstructionType' is a constant, code optimizer will eliminate
			// the 'switch' instruction and the 'dead code' for the unreachable
			// cases.
			//
  int nTemp;
	switch (nInstructionType)
	{
	  case typeIdleLoop:
		{
		  nTemp = typeIdleLoop;  // So that branch does not get optimized out
		  break;
		}

		case typeAlive:
		{
			alive(); alive();	alive(); alive();	alive();
			alive(); alive(); alive(); alive(); alive();
		  nTemp = typeAlive;
		  break;
		}

		case typeIntegerAssignConstant:
		{
			iArray[00] = 250; iArray[01] = 250; iArray[02] = 250; iArray[03] = 250; iArray[04] = 250;
			iArray[05] = 250; iArray[06] = 250; iArray[07] = 250; iArray[08] = 250; iArray[09] = 250;
		  nTemp = typeIntegerAssignConstant;
		  break;
		}

		case typeIntegerAssignVariable:
		{
			iArray[00] = i; iArray[01] = i; iArray[02] = i; iArray[03] = i; iArray[04] = i;
			iArray[05] = i; iArray[06] = i; iArray[07] = i; iArray[08] = i; iArray[09] = i;
		  nTemp = typeIntegerAssignVariable;
		  break;
		}

		case typeIntegerAssignSensor:
		{
			iArray[00] = SensorValue[in1]; iArray[01] = SensorValue[in1];
			iArray[02] = SensorValue[in1]; iArray[03] = SensorValue[in1];
			iArray[04] = SensorValue[in1]; iArray[05] = SensorValue[in1];
			iArray[06] = SensorValue[in1]; iArray[07] = SensorValue[in1];
			iArray[08] = SensorValue[in1]; iArray[09] = SensorValue[in1];
		  nTemp = typeIntegerAssignSensor;
		  break;
		}

		case typeIntegerAssignIndexed:
		{
			iArray[i + 00] = 50; iArray[i + 01] = 50; iArray[i + 02] = 50;
			iArray[i + 03] = 50; iArray[i + 04] = 50; iArray[i + 05] = 50;
			iArray[i + 06] = 50; iArray[i + 07] = 50; iArray[i + 08] = 50;
			iArray[i + 09] = 50;
		  nTemp = typeIntegerAssignIndexed;
		  break;
		}

		case typeIntegerAddVariable:
		{
			// Have to use alternating assignments to 'i' and 'j'; otherwise
			// code optimizer will simplify into single 'i += 20*333'

			iArray[00] += i; iArray[01] += i; iArray[02] += i;
			iArray[03] += i; iArray[04] += i; iArray[05] += i;
			iArray[06] += i; iArray[07] += i; iArray[08] += i;
			iArray[09] += i;
		  nTemp = typeIntegerAddVariable;
		  break;
		}

		case typeIntegerAddConstant:
		{
			// Have to use alternating assignments to 'i' and 'j'; otherwise
			// code optimizer will simplify into single 'i ++= 20*333'

			iArray[00] += 250; iArray[01] += 250; iArray[02] += 250;
			iArray[03] += 250; iArray[04] += 250; iArray[05] += 250;
			iArray[06] += 250; iArray[07] += 250; iArray[08] += 250;
			iArray[09] += 250;
		  nTemp = typeIntegerAddConstant;
		  break;
		}

#if defined(useLongs)
		case typeLongAssignConstant:
		{
			lArray[00] = 175; lArray[01] = 175; lArray[02] = 175;
			lArray[03] = 175; lArray[04] = 175; lArray[05] = 175;
			lArray[06] = 175; lArray[07] = 175; lArray[08] = 175;
			lArray[09] = 175;
		  nTemp = typeLongAssignConstant;
		  break;
		}

		case typeLongAssignVariable:
		{
			lArray[00] = lArray[9]; lArray[01] = lArray[9]; lArray[02] = lArray[9];
			lArray[03] = lArray[9]; lArray[04] = lArray[9]; lArray[05] = lArray[9];
			lArray[06] = lArray[9]; lArray[07] = lArray[9]; lArray[08] = lArray[9];
			lArray[09] = lArray[9];
		  nTemp = typeLongAssignVariable;
		  break;
		}

		case typeLongAssignIndexed:
		{
			lArray[i + 00] = 50; lArray[i + 01] = 50; lArray[i + 02] = 50;
			lArray[i + 03] = 50; lArray[i + 04] = 50; lArray[i + 05] = 50;
			lArray[i + 06] = 50; lArray[i + 07] = 50; lArray[i + 08] = 50;
			lArray[i + 09] = 50;
		  nTemp = typeLongAssignIndexed;
		  break;
		}
#endif

#if defined(useLongs)
		case typeLongAddConstant:
		{
			lArray[00] += 120; lArray[01] += 120; lArray[02] += 120;
			lArray[03] += 120; lArray[04] += 120; lArray[05] += 120;
			lArray[06] += 120; lArray[07] += 120; lArray[08] += 120;
			lArray[09] += 120;
		  nTemp = typeLongAddConstant;
		  break;
		}

		case typeLongAddVariable:
		{
			lArray[00] += iArray[09]; lArray[01] += iArray[09]; lArray[02] += iArray[09];
			lArray[03] += iArray[09]; lArray[04] += iArray[09]; lArray[05] += iArray[09];
			lArray[06] += iArray[09]; lArray[07] += iArray[09]; lArray[08] += iArray[09];
			lArray[09] += iArray[09];
		  nTemp = typeLongAddVariable;
		  break;
		}

		case typeLongTimes:
		{
			lArray[00] *= 3; lArray[01] *= 3; lArray[02] *= 3;
			lArray[03] *= 3; lArray[04] *= 3; lArray[05] *= 3;
			lArray[06] *= 3; lArray[07] *= 3; lArray[08] *= 3;
			lArray[09] *= 3;
		  nTemp = typeLongTimes;
		  break;
		}
#endif

#if defined(useFloats)
		case typeFloatAssignConstant:
		{
			fArray[00] = 3.357; fArray[01] = 3.357; fArray[02] = 3.357;
			fArray[03] = 3.357; fArray[04] = 3.357; fArray[05] = 3.357;
			fArray[06] = 3.357; fArray[07] = 3.357; fArray[08] = 3.357;
			fArray[09] = 3.357;
			nTemp = typeFloatAssignConstant;
			break;
		}

		case typeFloatAssignVariable:
		{
			fArray[00] = fTemp; fArray[01] = fTemp; fArray[02] = fTemp;
			fArray[03] = fTemp; fArray[04] = fTemp; fArray[05] = fTemp;
			fArray[06] = fTemp; fArray[07] = fTemp; fArray[08] = fTemp;
			fArray[09] = fTemp;
			nTemp = typeFloatAssignVariable;
			break;
		}

		case typeFloatAddVariable:
		{
			fArray[00] += fTemp; fArray[01] += fTemp; fArray[02] += fTemp;
			fArray[03] += fTemp; fArray[04] += fTemp; fArray[05] += fTemp;
			fArray[06] += fTemp; fArray[07] += fTemp; fArray[08] += fTemp;
			fArray[09] += fTemp;
		  nTemp = typeFloatAddVariable;
		  break;
		}

		case typeFloatAddConstant:
		{
			fArray[00] += 102.3; fArray[01] += 102.3; fArray[02] += 102.3;
			fArray[03] += 102.3; fArray[04] += 102.3; fArray[05] += 102.3;
			fArray[06] += 102.3; fArray[07] += 102.3; fArray[08] += 102.3;
			fArray[09] += 102.3;
		  nTemp = typeFloatAddConstant;
		  break;
		}

		case typeFloatTimes:
		{
			fArray[00] *= fTemp; fArray[01] *= fTemp; fArray[02] *= fTemp;
			fArray[03] *= fTemp; fArray[04] *= fTemp; fArray[05] *= fTemp;
			fArray[06] *= fTemp; fArray[07] *= fTemp; fArray[08] *= fTemp;
			fArray[09] *= fTemp;
		  nTemp = typeFloatTimes;
		  break;
		}
#endif

#if defined(NXT) || defined(TETRIX)
		case typeClearScreen:
		{
			eraseDisplay();
			eraseDisplay();
			eraseDisplay();
			eraseDisplay();
			eraseDisplay();

			eraseDisplay();
			eraseDisplay();
			eraseDisplay();
			eraseDisplay();
			eraseDisplay();
		  nTemp = typeClearScreen;
		  break;
		}

		case typeClearPixel:
		{
			nxtClearPixel(22, 22);
			nxtClearPixel(22, 22);
			nxtClearPixel(22, 22);
			nxtClearPixel(22, 22);
			nxtClearPixel(22, 22);

			nxtClearPixel(22, 22);
			nxtClearPixel(22, 22);
			nxtClearPixel(22, 22);
			nxtClearPixel(22, 22);
			nxtClearPixel(22, 22);
		  nTemp = typeClearPixel
		  ; break;
		}

		case typeRectangleErase:
		{
			nxtEraseRect(22, 22, 52, 52);
			nxtEraseRect(22, 22, 52, 52);
			nxtEraseRect(22, 22, 52, 52);
			nxtEraseRect(22, 22, 52, 52);
			nxtEraseRect(22, 22, 52, 52);

			nxtEraseRect(22, 22, 52, 52);
			nxtEraseRect(22, 22, 52, 52);
			nxtEraseRect(22, 22, 52, 52);
			nxtEraseRect(22, 22, 52, 52);
			nxtEraseRect(22, 22, 52, 52);
		  nTemp = typeRectangleErase;
		  break;
		}

		case typeRectangleFill:
		{
			nxtFillRect(22, 22, 52, 52);
			nxtFillRect(22, 22, 52, 52);
			nxtFillRect(22, 22, 52, 52);
			nxtFillRect(22, 22, 52, 52);
			nxtFillRect(22, 22, 52, 52);

			nxtFillRect(22, 22, 52, 52);
			nxtFillRect(22, 22, 52, 52);
			nxtFillRect(22, 22, 52, 52);
			nxtFillRect(22, 22, 52, 52);
			nxtFillRect(22, 22, 52, 52);
		  nTemp = typeRectangleFill;
		  break;
		}

		case typeRectangleDraw:
		{
			nxtDrawRect(22, 22, 52, 52);
			nxtDrawRect(22, 22, 52, 52);
			nxtDrawRect(22, 22, 52, 52);
			nxtDrawRect(22, 22, 52, 52);
			nxtDrawRect(22, 22, 52, 52);

			nxtDrawRect(22, 22, 52, 52);
			nxtDrawRect(22, 22, 52, 52);
			nxtDrawRect(22, 22, 52, 52);
			nxtDrawRect(22, 22, 52, 52);
			nxtDrawRect(22, 22, 52, 52);
		  nTemp = typeRectangleDraw;
		  break;
		}

#if (0)
		case typeIOMapRead:
		{
			const int kOffset = 0;
			const int kNumberOfBytes = 1;
			byte nBuffer[10];
			const string pzModule1 = "UI.mod";
			const string pzModule2 = "Display.mod";
#if (0)

			nxtReadIOMap(pzModule1, ioResult, nBuffer[0], kOffset, kNumberOfBytes);
			nxtReadIOMap(pzModule1, ioResult, nBuffer[0], kOffset, kNumberOfBytes);
			nxtReadIOMap(pzModule1, ioResult, nBuffer[0], kOffset, kNumberOfBytes);
			nxtReadIOMap(pzModule1, ioResult, nBuffer[0], kOffset, kNumberOfBytes);
			nxtReadIOMap(pzModule1, ioResult, nBuffer[0], kOffset, kNumberOfBytes);
			nxtReadIOMap(pzModule1, ioResult, nBuffer[0], kOffset, kNumberOfBytes);
			nxtReadIOMap(pzModule1, ioResult, nBuffer[0], kOffset, kNumberOfBytes);
			nxtReadIOMap(pzModule1, ioResult, nBuffer[0], kOffset, kNumberOfBytes);
			nxtReadIOMap(pzModule1, ioResult, nBuffer[0], kOffset, kNumberOfBytes);
			nxtReadIOMap(pzModule1, ioResult, nBuffer[0], kOffset, kNumberOfBytes);
#else
			nUiOMap.OBPPointer += 1;
			nUiOMap.OBPPointer += 1;
			nUiOMap.OBPPointer += 1;
			nUiOMap.OBPPointer += 1;
			nUiOMap.OBPPointer += 1;
			nUiOMap.OBPPointer += 1;
			nUiOMap.OBPPointer += 1;
			nUiOMap.OBPPointer += 1;
			nUiOMap.OBPPointer += 1;
			nUiOMap.OBPPointer += 20;
#endif
		  nTemp = typeIOMapRead;
		  break;
		}
#endif
#endif

#if defined(hasTranscendentalSupport)
		case typeSine:
		{
			fTemp *= 1.05;
			fArray[00] = sin(fTemp); fArray[01] = sin(fTemp); fArray[02] = sin(fTemp);
			fArray[03] = sin(fTemp); fArray[04] = sin(fTemp); fArray[05] = sin(fTemp);
			fArray[06] = sin(fTemp); fArray[07] = sin(fTemp); fArray[08] = sin(fTemp);
			fArray[09] = sin(fTemp);
		  nTemp = typeSine;
		  break;
		}

		case typeCosine:
		{
			fTemp *= 1.05;
			fArray[00] = cos(fTemp); fArray[01] = cos(fTemp); fArray[02] = cos(fTemp);
			fArray[03] = cos(fTemp); fArray[04] = cos(fTemp); fArray[05] = cos(fTemp);
			fArray[06] = cos(fTemp); fArray[07] = cos(fTemp); fArray[08] = cos(fTemp);
			fArray[09] = cos(fTemp);
		  nTemp = typeCosine;
		  break;
		}
#endif

		case typeLogical:
		{
#if defined(useLongs)
			iArray[00] = (l1 < l2); iArray[01] = (l1 < l2); iArray[02] = (l1 < l2); iArray[03] = (l1 < l2); iArray[04] = (l1 < l2);
			iArray[07] = (l1 < l2); iArray[06] = (l1 < l2); iArray[07] = (l1 < l2); iArray[08] = (l1 < l2); iArray[09] = (l1 < l2);
#endif
		  nTemp = typeLogical;
		  break;
		}

		case typeTrinaryAdd:
		{
			iArray[00] = i + k; iArray[01] = i + k; iArray[02] = k + i;
			iArray[03] = i + k; iArray[04] = i + k; iArray[05] = k + i;
			iArray[06] = i + k; iArray[07] = i + k; iArray[08] = k + i;
			iArray[09] = i + k;
		  nTemp = typeTrinaryAdd;
		  break;
		}

		case typeTrinaryAddConstant1:
		{
			iArray[00] = i + 333; iArray[01] = i + 333; iArray[02] = 333 + i;
			iArray[03] = i + 333; iArray[04] = i + 333; iArray[05] = 333 + i;
			iArray[06] = i + 333; iArray[07] = i + 333; iArray[08] = 333 + i;
			iArray[09] = i + 333;
		  nTemp = typeTrinaryAddConstant1;
		  break;
		}

		case typeTrinaryAddConstant2:
		{
			iArray[00] = i + 127; iArray[01] = i + 127; iArray[02] = 127 + i;
			iArray[03] = i + 127; iArray[04] = i + 127; iArray[05] = 127 + i;
			iArray[06] = i + 127; iArray[07] = i + 127; iArray[08] = 127 + i;
			iArray[09] = i + 127;
		  nTemp = typeTrinaryAddConstant2;
		  break;
		}
	  }
	}
	loopTime = time1[executionTimer];
#if defined(useFloats)
	loopTime /= 100.0;
#endif
	if (nInstructionType == typeIdleLoop)
	  elapsed = loopTime;
	else
	  elapsed = loopTime - idleLoopTime;
	nElapsedTime[nInstructionType] = elapsed;

	// 'elapsed' contains the number of 10 msec 'ticks' to execute 100,000 (5,000 loops
	// each with 20) statements. Thus if 'elapsed' is 146, a single statement took
	// 14.6 microseconds:
	//   - 1,460 millisecons total 'adjusted' time in loop (146 ticks x 10 milliseconds)
	//   - 1,460 milliseconds is same as 1,460,000 microseconds
	//   - divide by 100,000 to get 14.6 microseconds

	PlaySound(soundBlip);
	return;
}



task main()
{
	ClearTimer(T1);
	wait1Msec(200);
	SensorType[left] 		= testSensorType;
	SensorType[middle] 	= testSensorType;
	SensorType[right] 	= testSensorType;
	bFloatConversionErrors = false;

	for (TInstructions index = typeIdleLoop; index < typeLast; ++index)
	{
	  nElapsedTime[index] = 0.0;
  }


	//memset(nElapsedTime, 0, sizeof(nElapsedTime));

	ClearTimer(T1);
	while (true)
	{
	  measureTime(typeIdleLoop);
		measureTime(typeAlive);

		measureTime(typeIntegerAssignConstant);
		measureTime(typeIntegerAddConstant);
		measureTime(typeIntegerAssignVariable);
		measureTime(typeIntegerAssignIndexed);
		measureTime(typeIntegerAddVariable);
		measureTime(typeIntegerAssignSensor);

		measureTime(typeLongAssignConstant);
		measureTime(typeLongAssignVariable);
		measureTime(typeLongAssignIndexed);
		measureTime(typeLongAddConstant);
		measureTime(typeLongAddVariable);
		measureTime(typeLongTimes);

		measureTime(typeFloatAssignConstant);
		measureTime(typeFloatAssignVariable);
		measureTime(typeFloatAddConstant);
		measureTime(typeFloatAddVariable);
		measureTime(typeFloatTimes);
	#if defined(hasTranscendentalSupport)
		measureTime(typeSine);
		measureTime(typeCosine);
	#endif

		measureTime(typeLogical);

		measureTime(typeTrinaryAdd);
		measureTime(typeTrinaryAddConstant1);
		measureTime(typeTrinaryAddConstant2);

	#if defined(NXT) || defined(TETRIX)
		measureTime(typeClearScreen);
		measureTime(typeClearPixel);
		measureTime(typeRectangleDraw);
		measureTime(typeRectangleErase);
		measureTime(typeRectangleFill);
		//measureTime(typeIOMapRead);
	#endif


		PlaySound(soundBeepBeep);
	}
	return;
}
