#pragma config(Sensor, dgtl1,  sTiltLimitU,         sensorTouch)
#pragma config(Sensor, dgtl2,  sTiltLimitD,         sensorTouch)
#pragma config(Sensor, dgtl3,  sPanEncoder,         sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  sTiltEncoder,        sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  sTiltLimitG,         sensorTouch)
#pragma config(Motor,  port2,           trigger,       tmotorNormal, openLoop)
#pragma config(Motor,  port3,           tilt1,         tmotorNormal, openLoop)
#pragma config(Motor,  port4,           tilt2,         tmotorNormal, openLoop)
#pragma config(Motor,  port5,           pan1,          tmotorNormal, openLoop)
#pragma config(Motor,  port6,           pan2,          tmotorNormal, openLoop)
#pragma config(Motor,  port7,           pan1R,         tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port8,           pan2R,         tmotorNormal, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
VEXNET GAme Controller Assiognments:

Ch1 - move base left or right
Ch3 - move gun up or down
Button 7U - calibrate motors    DO NOT TOUCH THE JOYSTICKS OR PRESS ANY BUTTONS WHEN PRESSING THE CALIBRATE BUTTON
Button 8R - enables auto shooting
Button 5U - gun safety
Button 5D - gun trigger

NOTE: hold down buttons 5U and 5D to shoot one round.  Hold down 8R, 5U, and 5D to shoot multiple rounds

Button 8D - toggle between auto/user control
*/

// Initiate motor vars
int MotorTilt;
int MotorPan;
int MotorTrigger;
// Initiate sensor vars
bool TiltLimitU;
bool TiltLimitD;
bool TiltLimitG;
int TiltEncoder;
int PanEncoder;
// Initiate misc vars
bool Shoot;
bool UserControl;
bool AutoShotMode;
// Initiate vars used for motor calibration
int MotorPanF;
int MotorTiltF;
int MotorTriggerF;
// Initiate function/task prototypes
void CalibrateMotors();
void UserFunction();
void AutoFunction();
task GlobalUpdateVars();
task ShootGun();

void UserFunction()
{
  // Begin user control
  wait10Msec(10);

  while(UserControl)
  {
    // route controller joysticks to motor vars

    // Pan motor soft start/stop
    while (MotorPan != vexRT[Ch1])
    {
      if (vexRT[Ch1] > MotorPan)
        MotorPan++;
      else if (vexRT[Ch1] < MotorPan)
        MotorPan--;

      wait1Msec(5);
    }

    MotorTilt = vexRT[Ch3];
  }
}

void AutoFunction()
{
  // Begin autonomous function
  wait10Msec(10);
  CalibrateMotors();
  while (!UserControl)
  {
    // Autonomous function goes here

  }
}

void CalibrateMotors()
{
  // DO NOT MOVE THE JOYSTICKS WHILE CALIBRATING
  const int ZSpeed = 0;

  MotorTiltF = MotorTilt - ZSpeed;
  MotorPanF = MotorPan - ZSpeed;
  MotorTriggerF = MotorTrigger - ZSpeed;
}

task GlobalUpdateVars()
{
  while (true)
  {
    // Update sensor vars
    TiltLimitU = SensorValue[sTiltLimitU];
    TiltLimitD = SensorValue[sTiltLimitD];
    TiltLimitG = SensorValue[sTiltLimitG];
    TiltEncoder = SensorValue[sTiltEncoder];
    PanEncoder = SensorValue[sPanEncoder];

    // Update motor vars
    motor[trigger] = MotorTrigger - MotorTriggerF;
    motor[pan1] = MotorPan - MotorPanF;
    motor[pan2] = MotorPan - MotorPanF;
    motor[pan1R] = MotorPan - MotorPanF;
    motor[pan2R] = MotorPan - MotorPanF;
    if ((TiltLimitU && (MotorTilt < 0)) || ((TiltLimitD || TiltLimitG) && (MotorTilt > 0)))
    {
      motor[tilt1] = 0 - MotorTiltF;
      motor[tilt2] = 0 - MotorTiltF;
    }
    else
    {
      motor[tilt1] = MotorTilt - MotorTiltF;
      motor[tilt2] = MotorTilt - MotorTiltF;
    }

    // Toggles between user/autonmous functions
    if (vexRT[Btn8D])
    {
      // Clean up vars before toggling
      MotorTilt = MotorPan = MotorTrigger = 0;
      MotorPanF = MotorTiltF = MotorTriggerF = 0;
      Shoot = AutoShotMode = FALSE;

      // Toggle modes
      UserControl = !UserControl;

      while (vexRT[Btn8D])
      {
      }
    }

    Shoot = vexRT[Btn5U] && vexRT[Btn5D];

    if (vexRT[Btn7U])
      CalibrateMotors();

    if (vexRT[Btn8R])
      AutoShotMode = TRUE;
    else
      AutoShotMode = FALSE;
  }
}

task ShootGun()
{
  // Use a separate indepependent task to control the trigger switch. It runs in parallel with the 'main'
  // task that is providing the pan and tilt movement. That way the delays for gun operation do not intefere
  // with the continued operation of pan and tilt movements

  const int kTriggerOnDuration  = 250;
  const int kTimeBetweenShots   = 100;

  while (true)
  {
    if (Shoot)
    {
      if (AutoShotMode)
      {
        while (Shoot)
          MotorTrigger = 127;

        MotorTrigger = 0;
      }
      else
      {
        MotorTrigger = 127;
        wait1Msec(kTriggerOnDuration);
        MotorTrigger = 0;

        while (Shoot)
        {
          // single shot mode. Must release trigger before next shot.
        }
        wait1Msec(kTimeBetweenShots);
      }
    }
  }
}

task main()
{
  // Start required tasks
  StartTask(GlobalUpdateVars);
  StartTask(ShootGun);

  UserControl = TRUE;   // Default; will invert to 'TRUE' once GlobalUpdateVars task is called

  while (true)
  {
    // Determine the either to enter user or autonomous mode
    if (  )
      UserFunction();
    else
      AutoFunction();
    }
}
