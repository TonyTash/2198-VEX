#pragma config(Sensor, dgtl1,  upperPan,            sensorTouch)
#pragma config(Sensor, dgtl2,  lowerPan,            sensorTouch)
#pragma config(Sensor, dgtl3,  pan,                 sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  tilt,                sensorQuadEncoder)
#pragma config(Motor,  port3,           trigger,       tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port4,           tilt,          tmotorNormal, openLoop)
#pragma config(Motor,  port5,           pan1,          tmotorNormal, openLoop)
#pragma config(Motor,  port6,           pan2,          tmotorNormal, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int motorShadow[(tMotor) 10];

task shootGun()
{
  // Use a separate indepependent task to control the trigger switch. It runs in parallel with the 'main'
  // task that is providing the pan and tilt movement. That way the delays for gun operation do not intefere
  // with the continued operation of pan and tilt movements

  const int kTriggerOnDuration  = 250;
  const int kTimeBetweenShots   = 100;

  while (true)
  {
    if (vexRT[Btn5D] || vexRT[Btn5U])
    {
      motor[trigger] = 127;
      wait1Msec(kTriggerOnDuration);
      motor[trigger] = 0;

      while (vexRT[Btn5D] || vexRT[Btn5U])
      {
        // single shot mode. Must release trigger before next shot.
      }
      wait1Msec(kTimeBetweenShots);
    }
  }
}


task main()
{
  StartTask(shootGun);

  while (true)
  {
    int nKludge;

    nKludge = vexRT[Ch3];
    nKludge = 0 - nKludge;
    if (SensorValue[lowerPan] && (nKludge > 0))
      motor[tilt] = 0;
    else if (SensorValue[upperPan] && (nKludge < 0))
      motor[tilt] = 0;
    else
      motor[tilt] = motorShadow[tilt] = nKludge;

    // Need to add check to turn tilt motor off when limit switch reached.

    motor[pan1] = motorShadow[pan1] = vexRT[Ch1];
    motor[pan2] = motorShadow[pan2] = vexRT[Ch1];
  }
}
