#pragma config(Sensor, in1,    left4,               sensorLineFollower)
#pragma config(Sensor, in2,    left3,               sensorLineFollower)
#pragma config(Sensor, in3,    left2,               sensorLineFollower)
#pragma config(Sensor, in4,    left1,               sensorLineFollower)
#pragma config(Sensor, in5,    right1,              sensorLineFollower)
#pragma config(Sensor, in6,    right2,              sensorLineFollower)
#pragma config(Sensor, in7,    right3,              sensorLineFollower)
#pragma config(Sensor, in8,    right4,              sensorLineFollower)
#pragma config(Sensor, dgtl5,  OnOffButton,         sensorTouch)
#pragma config(Motor,  port2,           leftMotor,     tmotorNormal, openLoop)
#pragma config(Motor,  port3,           rightMotor,    tmotorNormal, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform (VEX)

int nErrorValue;
int nLastError;
int nDerivative;
int nCycles = 0;

int nAdjustment;
int nLeftMotor;
int nRightMotor;

int nMaxSpeed = 127; //40
int nPFactor =  20; //10
int nIFactor =   0;
int nDFactor =  50; //45

bool bMotorsDisabled  = true;
bool bClickInProgress = false;

//////////////////////////////////////////////////////////////////////////////
//
//                              getLineErrorPosition
//
// Uses the line follower sensors to calculate the error position -- i.e. the
// position of the line from the center point of the sensor array.
//
//////////////////////////////////////////////////////////////////////////////

int getLineErrorPosition()
{
  static int nLastPos = 0;
  int nPos = 0;
  int nNumbOfHits = 0;
  const int kThreshold1 = 350;
  const int kThreshold2 = 700;
  const int kThreshold3 = 900;

#define checkSensor(nSensor, nWeight)\
if (SensorValue[nSensor]  > kThreshold1)\
{\
  if (SensorValue[nSensor] > kThreshold3)\
    {nPos += 3 * nWeight; nNumbOfHits += 3;}\
  else if (SensorValue[nSensor] > kThreshold2)\
    {nPos += 2 * nWeight; nNumbOfHits += 2;}\
  else \
    {nPos += 1 * nWeight; nNumbOfHits += 1;}\
}
  checkSensor(left4,   +160);
  checkSensor(left3,   +120);
  checkSensor(left2,   +70); //70
  checkSensor(left1,   +20); //30
  checkSensor(right1,  -20);
  checkSensor(right2,  -70);
  checkSensor(right3,  -120);
  checkSensor(right4,  -160);

  switch (nNumbOfHits)
  {
  case 0:
    // Line was not detected. Use the last detected value
    return nLastPos;

  case 1:
    break;

  default:
    nPos /= nNumbOfHits;
    break;
  }
  nLastPos = nPos;      // Save the last detected position
  return nPos;
}

void processButton()
{
  if (bClickInProgress)
  {
    if (SensorValue[OnOffButton])
      bClickInProgress = false;
  }
  else
  {
    if (!SensorValue[OnOffButton])
    {
      bMotorsDisabled = !bMotorsDisabled;
      bClickInProgress = true;
    }
  }
}

task main()
{
  time1[T1] = 0;
  while (true)
  {
    ++nCycles;
    processButton();

    nErrorValue = getLineErrorPosition();
    nDerivative = nErrorValue - nLastError;
    nAdjustment = ((nErrorValue * nPFactor) + (nDerivative * nDFactor))/ 100;
    nLastError  = nErrorValue;

    if (nAdjustment > 0)
    {
      nLeftMotor  = nMaxSpeed + nAdjustment;
      nRightMotor = nMaxSpeed - 10 * nAdjustment / 2; //8
    }
    else
    {
      nLeftMotor  = nMaxSpeed + 10 * nAdjustment / 2;
      nRightMotor = nMaxSpeed - nAdjustment;
    }


    if (bMotorsDisabled)
    {
      motor[leftMotor]  = 0;
      motor[rightMotor] = 0;
    }
    else
    {
      motor[leftMotor]  = nLeftMotor;
      motor[rightMotor] = nRightMotor;
    }

    static int nLastVexSPIMsgCounts = 0;
    int nCurrVexSPIMsgCounts = 0;

    while (true)
    {
	    nCurrVexSPIMsgCounts = nVexSPIMsgCounts;
		  if (nCurrVexSPIMsgCounts != nLastVexSPIMsgCounts)
		  {
        nLastVexSPIMsgCounts = nVexSPIMsgCounts;
		    break;
		  }
	  }

    time1[T1] = 0;
    while (time1[T1] < 13)
    {}
  }
  return;
}
