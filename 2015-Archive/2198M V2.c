#pragma config(Sensor, dgtl12, limitUp,        sensorTouch)
#pragma config(Motor,  port2,           shooterTop,    tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port3,           conveyor,      tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port4,           frontLeft,     tmotorVex393, openLoop)
#pragma config(Motor,  port5,           frontRight,    tmotorVex393, openLoop)
#pragma config(Motor,  port6,           backLeft,      tmotorVex393, openLoop)
#pragma config(Motor,  port7,           backRight,     tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port8,           rotation,      tmotorVex393, openLoop)
#pragma config(Motor,  port9,           shooterBottom, tmotorVex393HighSpeed, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

int s1 = 70;
int s2 = 23;

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(105)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

int threshold = 20;

bool pressed = true;
/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{

	motor[shooterBottom] = 127;
	motor[shooterTop] = 127;
	wait10Msec(300);
	motor[conveyor] = 127;
	wait10Msec(50);
	motor[conveyor] = 0;
	wait10Msec(120);
	motor[conveyor] = 127;
	wait10Msec(50);
	motor[conveyor] = 0;
	wait10Msec(120);
	motor[conveyor] = 127;
	wait10Msec(50);
	motor[conveyor] = 0;

}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{

	while (true)
	{

    if(abs(vexRT[Ch2]) > threshold)         // If the left joystick is greater than or less than the threshold:
    {
    motor[frontRight] = vexRT[Ch2];
    motor[backRight]  = vexRT[Ch2];
    }
    else                                    // If the left joystick is within the threshold:
    {
    motor[frontRight] = 0;
    motor[backRight]  = 0;                // Stop the left motor (cancel noise)
    }

    if(abs(vexRT[Ch3]) > threshold)         // If the right joystick is greater than or less than the threshold:
    {
     motor[frontLeft] = vexRT[Ch3];
     motor[backLeft]  = vexRT[Ch3];
    }
    else                                    // If the right joystick is within the threshold:
    {
    motor[frontLeft] = 0;
    motor[backLeft]  = 0;                // Stop the right motor (cancel noise)
    }




    //Rotation Control

     if(vexRT[Btn5D] == 1)
    {
      motor[rotation] = -64;
    }
     else if(SensorValue(limitUp) == 1)
    {
      motor[rotation] = -8;
    }
     else if(vexRT[Btn5U] == 1)
    {
      motor[rotation] = 64;
    }
    else
    {
      motor[rotation] = 0;
    }

    //SHORT SHOT:
    // SHOOTER TOP: 9
    // SHOOTER BOTTOM: 80

    //Mashi Shot
    // SHOOTER TOP: 23
    // SHOOTER BOTTOM: 70

    //New Shot
    // SHOOTER TOP: 41
    // SHOOTER BOTTOM: 66

    // Temp var
    if(vexRT[Btn7R] && pressed) {
    	s1++;
    	pressed = false;
    } else
    if(vexRT[Btn7D] && pressed) {
    	s1--;
    	pressed = false;
    } else
    if(vexRT[Btn7L] && pressed) {
    	s2--;
    	pressed = false;
    } else
    if(vexRT[Btn7U] && pressed) {
    	s2++;
    	pressed = false;
    } else
    if(!vexRT[Btn7U] && !vexRT[Btn7D] && !vexRT[Btn7R] && !vexRT[Btn7L]){
    	pressed = true;
    }

    //Shooter Control
    if(vexRT[Btn6U] == 1)
    {
    	//motor[shooterBottom] = 127;
     // motor[shooterTop] = 127;
     // wait10Msec(75);
      motor[shooterBottom] = s1;
      motor[shooterTop] = s2;
    }
    else if(vexRT[Btn6D] == 1)
    {
    	//motor[shooterBottom] = 127;
     // motor[shooterTop] = 127;
     // wait10Msec(50);
      motor[shooterBottom] = -40;
      motor[shooterTop] = -40;
    }
    else
    {
      motor[shooterBottom] = 0;
      motor[shooterTop] = 0;
    }

    //Conveyor Control
    if(vexRT[Btn8L] == 1)
    {
      motor[conveyor] = 120;
    }
    else if(vexRT[Btn8D] == 1)
    {
      motor[conveyor] = -120;
    }
    else
    {
      motor[conveyor] = 0;
    }

	}
}
