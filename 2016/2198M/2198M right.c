#pragma config(Sensor, in1,    leftArmSensor,  sensorPotentiometer)
#pragma config(Sensor, in2,    rightArmSensor, sensorPotentiometer)
#pragma config(Sensor, dgtl1,  leftWheels,     sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightWheels,    sensorQuadEncoder)
#pragma config(Motor,  port1,           leftCollector, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port2,           right1,        tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port3,           right2,        tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port4,           right3,        tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port5,           left1,         tmotorVex393, openLoop)
#pragma config(Motor,  port6,           left2,         tmotorVex393, openLoop)
#pragma config(Motor,  port7,           left3,         tmotorVex393, openLoop)
#pragma config(Motor,  port8,           towerLeft,     tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port9,           towerRight,    tmotorVex393, openLoop)
#pragma config(Motor,  port10,          rightCollector, tmotorVex393, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//V4.0 potentiometer on
#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(105)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!




void forwardAuto(int speed)//distance in positive, remember to set sensor value to zero if needed; speed in positive
{
		if(SensorValue[leftWheels] > SensorValue[rightWheels])
		{
			motor[left1] = speed - (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[left2] = speed - (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[left3] = speed - (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[right1] = speed;
			motor[right2] = speed;
			motor[right3] = speed;
		}
		else if(SensorValue[leftWheels] < SensorValue[rightWheels])
		{
			motor[left1] = speed;
			motor[left2] = speed;
			motor[left3] = speed;
			motor[right1] = speed - (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[right2] = speed - (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[right3] = speed - (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
		}
		else if(SensorValue[leftWheels] == SensorValue[rightWheels])
		{
			motor[left1] = speed;
			motor[left2] = speed;
			motor[left3] = speed;
			motor[right1] = speed;
			motor[right2] = speed;
			motor[right3] = speed;
		}
}

void backwardAuto(int speed)//distance in negative, remember to set sensor value to zero if needed; speed in positive
{
		if(SensorValue[leftWheels] > SensorValue[rightWheels])
		{
			motor[left1] = -speed;
			motor[left2] = -speed;
			motor[left3] = -speed;
			motor[right1] = -speed + (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[right2] = -speed + (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[right3] = -speed + (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
		}
		else if(SensorValue[leftWheels] < SensorValue[rightWheels])
		{
			motor[left1] = -speed + (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[left2] = -speed + (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[left3] = -speed + (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[right1] = -speed;
			motor[right2] = -speed;
			motor[right3] = -speed;
		}
		else if(SensorValue[leftWheels] == SensorValue[rightWheels])
		{
			motor[left1] = -speed;
			motor[left2] = -speed;
			motor[left3] = -speed;
			motor[right1] = -speed;
			motor[right2] = -speed;
			motor[right3] = -speed;
		}
}

void ccwRotationBothSide(int degree, int speed)//degree in positive, and speed in positive for both side, program will set them to negative
{
	int distance = 7*degree/2;
	while(SensorValue[leftWheels] > -distance && SensorValue[rightWheels] < distance)
	{
		motor[left1] = -speed;
		motor[left2] = -speed;
		motor[left3] = -speed;
		motor[right1] = speed;
		motor[right2] = speed;
		motor[right3] = speed;
	}
}

void cwRotationBothSide(int degree,int speed)//degree in positive, and speed in positive for both side, program will set them to negative
{
	int distance = 7*degree/2;
	while(SensorValue[leftWheels] < distance && SensorValue[rightWheels] > -distance)
	{
		motor[left1] = speed;
		motor[left2] = speed;
		motor[left3] = speed;
		motor[right1] = -speed;
		motor[right2] = -speed;
		motor[right3] = -speed;
	}
}

void stopMoving()
{
	motor[left1] = 0;
	motor[left2] = 0;
	motor[left3] = 0;
	motor[right1] = 0;
	motor[right2] = 0;
	motor[right3] = 0;
}

void intake()
{
	motor[leftCollector] = 127;
	motor[rightCollector] = 127;
}

void outake()
{
	motor[leftCollector] = -127;
	motor[rightCollector] = -127;
}

void stopCollecting()
{
	motor[leftCollector] = 0;
	motor[rightCollector] = 0;
}

void armUp()
{
	motor[towerLeft] = 127;
	motor[towerRight] = 127;
}

void armDown()
{
	motor[towerLeft] = -127;
	motor[towerRight] = -127;
}
void armStop()
{
	motor[towerLeft] = 30;
	motor[towerRight] = 30;
}

void clearEncoder()
{
  SensorValue[leftWheels] = 0;
  SensorValue[rightWheels] = 0;
}

void pre_auton()
{
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//																																																																															//
//////////////////////////////////////////////////////////////////////Autonomous//////////////////////////////////////////////////////////////////////////////////
//                        																																																																		  //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


task autonomous()
{
	clearEncoder();
	while(SensorValue[leftArmSensor] > 3250 && SensorValue[rightArmSensor] < 740)
	{
		armUp();
	}
	armStop();
	wait1Msec(300);
	armDown();
	wait1Msec(200)
	armStop();
	while(SensorValue[leftWheels] < 550 && SensorValue[rightWheels] < 550)
	{
		forwardAuto(50);
		intake();
	}
	stopMoving();
	wait1Msec(800);
	while(SensorValue[leftArmSensor] > 3150 && SensorValue[rightArmSensor] < 840)
	{
		armUp();
	}
	armStop();
	stopCollecting();
	while(SensorValue[leftWheels] > -50 && SensorValue[rightWheels] > -50)
	{
		backwardAuto(50);
	}
	clearEncoder();
	ccwRotationBothSide(95,40);
	stopMoving();
	while(SensorValue[leftArmSensor] > 1590 && SensorValue[rightArmSensor] < 2100)
	{
		armUp();
	}
	armStop();
	clearEncoder();
	while(SensorValue[leftWheels] < 350 && SensorValue[rightWheels] < 350)
	{
		forwardAuto(40);
	}
	while(SensorValue[leftWheels] < 1380 && SensorValue[rightWheels] < 1380)
	{
		forwardAuto(80);
	}
	stopMoving();
	outake();
	wait1Msec(3000);
	stopCollecting();
	while(SensorValue[leftWheels] > 1200 && SensorValue[rightWheels] > 1200)
	{
		backwardAuto(40);
	}
	while(SensorValue[leftWheels] > 1000 && SensorValue[rightWheels] > 1000)
	{
		backwardAuto(40);
		armDown();
	}
	armStop();
	while(SensorValue[leftWheels] > 50 && SensorValue[rightWheels] > 50)
	{
		backwardAuto(40);
	}
	stopMoving();

}



task usercontrol()
{

//v2.2changelog: change collector control to 6U and 6D.

	while (true)
	{
		int lArm = (-SensorValue[leftArmSensor] + 3300);
		int rArm = SensorValue[rightArmSensor] - 700;
		int speed = abs(lArm - rArm)/10;
		//tank drive
	  motor[right1] = vexRT[Ch2];
	  motor[right3] = vexRT[Ch2];
	  motor[right2] = vexRT[Ch2];
	  motor[left1] = vexRT[Ch3];
	  motor[left2] = vexRT[Ch3];
	  motor[left3] = vexRT[Ch3];

	  //tower
	  if(SensorValue[leftArmSensor] < 3500 && SensorValue[rightArmSensor] > 600 && SensorValue[leftArmSensor] > 1685 && SensorValue[rightArmSensor] < 2330)
    {
  		//six bar seperately control
  		if(vexRT[Btn8U] == 1 && vexRT[Btn8R] == 1)
    	{
    		if(vexRT[Btn5U] == 1)
    			motor[towerLeft] = 127;
    		else if(vexRT[Btn5D] == 1)
    			motor[towerLeft] = -100;
    		else
    			motor[towerLeft] = 30;
    		if(vexRT[Btn6U] == 1)
    			motor[towerRight] = 127;
    		else if(vexRT[Btn6D] == 1)
    			motor[towerRight] = -100;
    		else
    			motor[towerRight] = 30;
  		}
  		//six bar collaboratively control.
    	else if(lArm == rArm)
    	{
   			if(vexRT[Btn5U] == 1)
   			{
   				motor[towerRight] = 127;
   				motor[towerLeft] = 127;
   			}
   			else	if(vexRT[Btn5D] == 1)
   			{
   				motor[towerRight] = -127;
   				motor[towerLeft] = -127;
   			}
   			else
   			{
   				motor[towerRight] = 30;
   				motor[towerLeft] = 30;
   			}
   		}
   		else if(lArm > rArm)
   		{
   			if(vexRT[Btn5U] == 1)
   			{
   				motor[towerRight] = 127;
   				motor[towerLeft] = 127-speed;
   			}
   			else if(vexRT[Btn5D] == 1)
   			{
   				motor[towerRight] = -100+speed;
   				motor[towerLeft] = -100;
   			}
   			else
   			{
   				motor[towerRight] = 0;
   				motor[towerLeft] = 0;
   	  	}
    	}
    	else if(lArm < rArm)
    	{
    		if(vexRT[Btn5U] == 1)
   			{
   				motor[towerRight] = 127-speed;
   				motor[towerLeft] = 127;
   			}
   			else if(vexRT[Btn5D] == 1)
   			{
   				motor[towerRight] = -100;
   				motor[towerLeft] = -100+speed;
   			}
   			else
   			{
   				motor[towerRight] = 30;
   				motor[towerLeft] = 30;
   	  	}
    	}
    }
    //lower than starting position.
    else if(SensorValue[leftArmSensor] > 3500 || SensorValue[rightArmSensor] < 600)
    {
    	if(vexRT[Btn8U] == 1 && vexRT[Btn8R] == 1)
    	{
    		if(vexRT[Btn5U] == 1)
    			motor[towerLeft] = 127;
    		else
    			motor[towerLeft] = 30;
    		if(vexRT[Btn6U] == 1)
    			motor[towerRight] = 127;
    		else
    			motor[towerRight] = 30;
  		}
    	else if(lArm == rArm)
    	{
   			if(vexRT[Btn5U] == 1)
   			{
   				motor[towerRight] = 127;
   				motor[towerLeft] = 127;
   			}
   			else
   			{
   				motor[towerRight] = 0;
   				motor[towerLeft] = 0;
   			}
   		}
   		else if(lArm > rArm)
   		{
   			if(vexRT[Btn5U] == 1)
   			{
   				motor[towerRight] = 127;
   				motor[towerLeft] = 127-speed;
   			}
   			else
   			{
   				motor[towerRight] = 0;
   				motor[towerLeft] = 0;
   	  	}
    	}
    	else if(lArm < rArm)
    	{
    		if(vexRT[Btn5U] == 1)
   			{
   				motor[towerRight] = 127-speed;
   				motor[towerLeft] = 127;
   			}
   			else
   			{
   				motor[towerRight] = 30;
   				motor[towerLeft] = 30;
   	  	}
    	}
    }
    //higher than highest position.
    else if(SensorValue[leftArmSensor] < 1685 || SensorValue[rightArmSensor] > 2330)
    {
    	if(vexRT[Btn8U] == 1 && vexRT[Btn8R] == 1)
    	{
    		if(vexRT[Btn5D] == 1)
    			motor[towerLeft] = -100;
    		else
    			motor[towerLeft] = 30;
    		if(vexRT[Btn6D] == 1)
    			motor[towerRight] = -100;
    		else
    			motor[towerRight] = 30;
  		}
    	else if(lArm == rArm)
    	{
   			if(vexRT[Btn5D] == 1)
   			{
   				motor[towerRight] = -100;
   				motor[towerLeft] = -100;
   			}
   			else
   			{
   				motor[towerRight] = 30;
   				motor[towerLeft] = 30;
   			}
   		}
   		else if(lArm > rArm)
   		{
   			if(vexRT[Btn5D] == 1)
   			{
   				motor[towerRight] = -100+speed;
   				motor[towerLeft] = -100;
   			}
   			else
   			{
   				motor[towerRight] = 0;
   				motor[towerLeft] = 0;
   	  	}
    	}
    	else if(lArm < rArm)
    	{
    		if(vexRT[Btn5D] == 1)
   			{
   				motor[towerRight] = -100;
   				motor[towerLeft] = -100+speed;
   			}
   			else
   			{
   				motor[towerRight] = 30;
   				motor[towerLeft] = 30;
   	  	}
    	}
    }

	  //collector
	  if(vexRT[Btn6U] == 1)
	  {
	  	motor[leftCollector] = 127;
	  	motor[rightCollector] = 127;
	  }
	  else if(vexRT[Btn6D] == 1)
	  {
	  	motor[leftCollector] = -127;
	  	motor[rightCollector] = -127;
	  }
	  else
	  {
	  	motor[leftCollector] = 0;
	  	motor[rightCollector] = 0;
	  }

	}
}
