#pragma config(Sensor, dgtl1,  leftWheels,     sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightWheels,    sensorQuadEncoder)
#pragma config(Motor,  port1,           leftCollector, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port2,           right1,        tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port3,           right2,        tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port4,           right3,        tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port5,           left1,         tmotorVex393, openLoop)
#pragma config(Motor,  port6,           left2,         tmotorVex393, openLoop)
#pragma config(Motor,  port7,           left3,         tmotorVex393, openLoop)
#pragma config(Motor,  port8,           towerLeft,     tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port9,           towerRight,    tmotorVex393, openLoop)
#pragma config(Motor,  port10,          rightCollector, tmotorVex393, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//V2.3 change: reduce the motor speed for the right tower.
#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(105)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

void forwardAuto(int speed)//distance in positive, remember to set sensor value to zero if needed; speed in positive
{
		if(SensorValue[leftWheels] > SensorValue[rightWheels])
		{
			motor[left1] = speed - (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[left2] = speed - (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[left3] = speed - (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[right1] = speed;
			motor[right2] = speed;
			motor[right3] = speed;
		}
		else if(SensorValue[leftWheels] < SensorValue[rightWheels])
		{
			motor[left1] = speed;
			motor[left2] = speed;
			motor[left3] = speed;
			motor[right1] = speed - (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[right2] = speed - (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[right3] = speed - (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
		}
		else if(SensorValue[leftWheels] == SensorValue[rightWheels])
		{
			motor[left1] = speed;
			motor[left2] = speed;
			motor[left3] = speed;
			motor[right1] = speed;
			motor[right2] = speed;
			motor[right3] = speed;
		}
}

void backwardAuto(int speed)//distance in negative, remember to set sensor value to zero if needed; speed in positive
{
		if(SensorValue[leftWheels] > SensorValue[rightWheels])
		{
			motor[left1] = -speed;
			motor[left2] = -speed;
			motor[left3] = -speed;
			motor[right1] = -speed + (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[right2] = -speed + (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[right3] = -speed + (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
		}
		else if(SensorValue[leftWheels] < SensorValue[rightWheels])
		{
			motor[left1] = -speed + (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[left2] = -speed + (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[left3] = -speed + (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[right1] = -speed;
			motor[right2] = -speed;
			motor[right3] = -speed;
		}
		else if(SensorValue[leftWheels] == SensorValue[rightWheels])
		{
			motor[left1] = -speed;
			motor[left2] = -speed;
			motor[left3] = -speed;
			motor[right1] = -speed;
			motor[right2] = -speed;
			motor[right3] = -speed;
		}
}

void ccwRotationBothSide(int degree, int speed)//degree in positive, and speed in positive for both side, program will set them to negative
{
	int distance = 6*degree/2;
	while(SensorValue[leftWheels] > -distance && SensorValue[rightWheels] < distance)
	{
		motor[left1] = -speed;
		motor[left2] = -speed;
		motor[left3] = -speed;
		motor[right1] = speed;
		motor[right2] = speed;
		motor[right3] = speed;
	}
}

void cwRotationBothSide(int degree,int speed)//degree in positive, and speed in positive for both side, program will set them to negative
{
	int distance = 6*degree/2;
	while(SensorValue[leftWheels] < distance && SensorValue[rightWheels] > -distance)
	{
		motor[left1] = speed;
		motor[left2] = speed;
		motor[left3] = speed;
		motor[right1] = -speed;
		motor[right2] = -speed;
		motor[right3] = -speed;
	}
}

void stopMoving()
{
	motor[left1] = 0;
	motor[left2] = 0;
	motor[left3] = 0;
	motor[right1] = 0;
	motor[right2] = 0;
	motor[right3] = 0;
}

void intake()
{
	motor[leftCollector] = 127;
	motor[rightCollector] = 127;
}

void outake()
{
	motor[leftCollector] = -127;
	motor[rightCollector] = -127;
}

void stopCollecting()
{
	motor[leftCollector] = 0;
	motor[rightCollector] = 0;
}

void armUp()
{
	motor[towerLeft] = 127;
	motor[towerRight] = 127;
}

void armStop()
{
	motor[towerLeft] = 0;
	motor[towerRight] = 0;
}

void clearEncoder()
{
  SensorValue[leftWheels] = 0;
  SensorValue[rightWheels] = 0;
}



task autonomous()
{
	clearEncoder();
	while(SensorValue[leftWheels] < 508 && SensorValue[rightWheels] < 508)
	{
		forwardAuto(90);
		intake();
	}
	while(SensorValue[leftWheels] > 506 && SensorValue[rightWheels] > 506)
	{
		backwardAuto(90);
		intake();
	}
	stopMoving();
	wait1Msec(200);
	armUp();
	wait1Msec(500);
	armStop();
	clearEncoder();
	while(SensorValue[leftWheels] > -20 && SensorValue[rightWheels] > -20)
	{
		backwardAuto(60);
	}
	while(SensorValue[leftWheels] < -19 && SensorValue[rightWheels] < -19)
	{
		forwardAuto(90);
	}
	clearEncoder();
	ccwRotationBothSide(90,90);
	stopMoving();
	clearEncoder();
	cwRotationBothSide((2/6),90);
	stopMoving();
	armUp();
	wait1Msec(1000);
	clearEncoder();
	while(SensorValue[leftWheels] < 1000 && SensorValue[rightWheels] < 1000)
	{
		forwardAuto(90);
		armUp();
	}
	while(SensorValue[leftWheels] > 999 && SensorValue[rightWheels] > 999)
	{
		backwardAuto(60);
	}
	armUp();
	wait1Msec(1000);
	stopMoving();
	armStop();
	clearEncoder();
	while(SensorValue[leftWheels] < 50 && SensorValue[rightWheels] < 50)
	{
		forwardAuto(90);
		armUp();
	}
	outake();
	stopMoving();
}



task usercontrol()
{

//v2.2changelog: change collector control to 6U and 6D.

	while (true)
	{
		//tank drive
	  motor[right1] = vexRT[Ch2];
	  motor[right3] = vexRT[Ch2];
	  motor[right2] = vexRT[Ch2];
	  motor[left1] = vexRT[Ch3];
	  motor[left2] = vexRT[Ch3];
	  motor[left3] = vexRT[Ch3];

	  //tower
	  //seperated control
	  if(vexRT[Btn8U] == 1 && vexRT[Btn8R] == 1)
    {
    	if(vexRT[Btn5U] == 1)
    		motor[towerLeft] = 127;
    	else if(vexRT[Btn5D] == 1)
    		motor[towerLeft] = -127;
    	else
    		motor[towerLeft] = 0;
    	if(vexRT[Btn6U] == 1)
    		motor[towerRight] = 127;
    	else if(vexRT[Btn6D] == 1)
    		motor[towerRight] = -127;
    	else
    		motor[towerRight] = 0;
  	}
  	//six bars move together
	  else if(vexRT[Btn5U] == 1)
	  {
	  	motor[towerLeft] = 127;
	  	motor[towerRight] = 115;
	  }
	  else if(vexRT[Btn5D] == 1)
	  {
	  	motor[towerLeft] = -127;
	  	motor[towerRight] = -115;
	  }
	  else
	  {
	  	motor[towerLeft] = 0;
	  	motor[towerRight] = 0;
	  }
	  //collector
	  if(vexRT[Btn6U] == 1)
	  {
	  	motor[leftCollector] = 127;
	  	motor[rightCollector] = 127;
	  }
	  else if(vexRT[Btn6D] == 1)
	  {
	  	motor[leftCollector] = -127;
	  	motor[rightCollector] = -127;
	  }
	  else
	  {
	  	motor[leftCollector] = 0;
	  	motor[rightCollector] = 0;
	  }

	}
}
