#pragma config(Motor,  port1,           frontLeft,     tmotorVex393, openLoop)
#pragma config(Motor,  port2,           frontRight,    tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port4,           armMotorRight, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port5,           armMotorLeft,  tmotorVex393, openLoop)
#pragma config(Motor,  port9,           backLeft,      tmotorVex393, openLoop)
#pragma config(Motor,  port10,          backRight,     tmotorVex393, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

// Arthemus: Created by Ali Shariatmadari

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(105)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
  // .....................................................................................
  // Insert user code here.
  // .....................................................................................

	AutonomousCodePlaceholderForTesting();  // Remove this function call once you have "real" code.
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{

	float motorSensitivity = 1.0;
  float armMotorSensitivity = 3.0;

	//R-SENSE OF 1.0 CAUSES STATIC ROTATION.
	float rotationSensitivity= 0.5;

	while (true){

    float RightY = vexRT[Ch2] / motorSensitivity;
		float RightX = vexRT[Ch1] / motorSensitivity;
		float LeftY = vexRT[Ch3] / motorSensitivity;
		float LeftX = vexRT[Ch4] / motorSensitivity;

		// Movement
		if (LeftY != 0){
			if (LeftX > 0){
				motor[frontRight] = LeftY;
				motor[backRight] = LeftY;
				motor[frontLeft] = LeftX / rotationSensitivity;
				motor[backLeft] = LeftX / rotationSensitivity;
			} else

			if (LeftX < 0){
				motor[frontRight] = LeftX / rotationSensitivity;
				motor[backRight] = LeftX / rotationSensitivity;
				motor[frontLeft] = LeftY;
				motor[backLeft] = LeftY;
			}
		} else

		if (LeftX > 0){
			motor[frontRight] = LeftX;
			motor[backRight] = LeftX;
			motor[frontLeft] = -LeftX;
			motor[backLeft] = -LeftX;
		}

		// ARM Movement
		if(vexRT[Btn6U] == 1)
    {
    	// Arm UP Movement
      motor[armMotorRight] = 127 / armMotorSensitivity;
      motor[armMotorLeft] = 127 / armMotorSensitivity;
    }
    else if(vexRT[Btn6D] == 1)
    {
    	// Arm Down Movement
      motor[armMotorRight] = -127 / armMotorSensitivity;
      motor[armMotorLeft] = -127 / armMotorSensitivity;
    }
    else
    {
    	// Disengage Arm Motors
      motor[armMotorRight] = 0;
      motor[armMotorLeft] = 0;
    }

    if(vexRT[Btn8U] == 1)
    {
    	// Increase ARM Sensitivity
    	armMotorSensitivity = armMotorSensitivity - 0.25;
    }
    else if(vexRT[Btn8R] == 1)
    {
    	// Decrease ARM Sensitivity
    	armMotorSensitivity = armMotorSensitivity + 0.25;
    }
    else if(vexRT[Btn8L] == 1)
    {
    	// Increase Motor Sensitivity
    	motorSensitivity = motorSensitivity - 0.25;
    }
    else if(vexRT[Btn8D] == 1)
    {
    	// Decrease Motor Sensitivity
    	motorSensitivity = armMotorSensitivity + 0.25;
    }
	}
}
