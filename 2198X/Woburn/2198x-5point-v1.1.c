#pragma config(Sensor, in1,    arm1,           sensorPotentiometer)
#pragma config(Sensor, in2,    arm2,           sensorPotentiometer)
#pragma config(Sensor, dgtl1,  rightDrive,     sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightMobile,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  leftMobile,     sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  leftDrive,      sensorQuadEncoder)
#pragma config(Motor,  port1,           frontRightMotor, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port2,           backRightMotor, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port3,           coneClawMotor, tmotorVex393, openLoop)
#pragma config(Motor,  port4,           coneRightMotor, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port5,           mobileRightMotor, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port6,           mobileLeftMotor, tmotorVex393, openLoop)
#pragma config(Motor,  port7,           coneLeftMotor, tmotorVex393, openLoop)
#pragma config(Motor,  port8,           mobileClawMotor, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port9,           backLeftMotor, tmotorVex393, openLoop)
#pragma config(Motor,  port10,          frontLeftMotor, tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(105)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

//Tasks

void forwardAuto(int speed)//distance in positive, remember to set sensor value to zero if needed; speed in positive
{
		if(SensorValue[leftDrive] < SensorValue[rightDrive])
		{
			motor[frontLeftMotor] = speed - (abs((SensorValue[leftDrive]) - (SensorValue[rightDrive])));
			motor[backLeftMotor] = speed - (abs((SensorValue[leftDrive]) - (SensorValue[rightDrive])));
			motor[frontRightMotor] = speed;
			motor[backRightMotor] = speed;
		}
		else if(SensorValue[leftDrive] > SensorValue[rightDrive])
		{
			motor[frontLeftMotor] = speed;
			motor[backLeftMotor] = speed;
			motor[frontRightMotor] = speed - (abs((SensorValue[leftDrive]) - (SensorValue[rightDrive])));
			motor[backRightMotor] = speed - (abs((SensorValue[leftDrive]) - (SensorValue[rightDrive])));
		}
		else if(SensorValue[leftDrive] == SensorValue[rightDrive])
		{
			motor[frontLeftMotor] = speed;
			motor[backLeftMotor] = speed;
			motor[frontRightMotor] = speed;
			motor[backRightMotor] = speed;
		}
}

void backwardAuto(int speed)//distance in negative, remember to set sensor value to zero if needed; speed in positive
{
		if(SensorValue[leftDrive] < SensorValue[rightDrive])
		{
			motor[frontLeftMotor] = -speed;
			motor[backLeftMotor] = -speed;
			motor[frontRightMotor] = -speed + (abs((SensorValue[leftDrive]) - (SensorValue[rightDrive])));
			motor[backRightMotor] = -speed + (abs((SensorValue[leftDrive]) - (SensorValue[rightDrive])));
		}
		else if(SensorValue[leftDrive] > SensorValue[rightDrive])
		{
			motor[frontLeftMotor] = -speed + (abs((SensorValue[leftDrive]) - (SensorValue[rightDrive])));
			motor[backLeftMotor] = -speed + (abs((SensorValue[leftDrive]) - (SensorValue[rightDrive])));
			motor[frontRightMotor] = -speed;
			motor[backRightMotor] = -speed;
		}
		else if(SensorValue[leftDrive] == SensorValue[rightDrive])
		{
			motor[frontLeftMotor] = -speed;
			motor[backLeftMotor] = -speed;
			motor[frontRightMotor] = -speed;
			motor[backRightMotor] = -speed;
		}
}

void ccwRotationBothSide(int degree, int speed)//degree in positive, and speed in positive for both side, program will set them to negative
{
	int distance = 7.5*degree/2;
	while(SensorValue[leftDrive] > -distance && SensorValue[rightDrive] < distance)
	{
		motor[frontLeftMotor] = -speed;
		motor[backLeftMotor] = -speed;
		motor[frontRightMotor] = speed;
		motor[backRightMotor] = speed;
	}
}

void cwRotationBothSide(int degree,int speed)//degree in positive, and speed in positive for both side, program will set them to negative
{
	int distance = 7.5*degree/2;
	while(SensorValue[leftDrive] < distance && SensorValue[rightDrive] > -distance)
	{
		motor[frontLeftMotor] = speed;
		motor[backLeftMotor] = speed;
		motor[frontRightMotor] = -speed;
		motor[backRightMotor] = -speed;
	}
}

void stopMoving()
{
	motor[frontLeftMotor] = 0;
	motor[backLeftMotor] = 0;
	motor[frontRightMotor] = 0;
	motor[backRightMotor] = 0;
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
  // .....................................................................................
  // Insert user code here.
  // .....................................................................................

	SensorValue[rightDrive] = 0;	  // Set the encoder so that it starts counting at 0
	SensorValue[leftDrive]  = 0;	  // Set the encoder so that it starts counting at 0

	SensorValue[rightMobile] = 0;	  // Set the encoder so that it starts counting at 0
	SensorValue[leftMobile]  = 0;	  // Set the encoder so that it starts counting at 0


	pre_auton();

	// Rotate left from starting position
	//while(SensorValue[rightDrive] < 345)
	//{
	//	//rotate right motors
	//	motor[frontRightMotor] = 90;
	//	motor[backRightMotor] = 90;

	//	//lift tower slightly
	//	motor[coneRightMotor] = (-60);
 //   motor[coneLeftMotor]  = (-60);

 //   //close cone claw
 //   motor[coneClawMotor] = 40;

	//}

	  //slow down motors to hold arm
		motor[coneRightMotor] = (-60);
    motor[coneLeftMotor]  = (-60);
    wait1Msec(250);


    // drive forward until mobile goal
	while(SensorValue[rightDrive] < 2000)
	{
		motor[frontLeftMotor] = 127;
		motor[backLeftMotor] = 127;
		motor[frontRightMotor] = 127;
		motor[backRightMotor] = 127;

		// open mobile goal holder
		motor[mobileClawMotor] = 95;
	}
	motor[coneRightMotor] = (-30);
  motor[coneLeftMotor]  = (-30);

	stopMoving();

	//lift mobile goal lift
		while(SensorValue[rightMobile] > -1400)
	{

		motor[mobileLeftMotor] = -127;
    motor[mobileRightMotor] = -127;
		motor[mobileClawMotor] = -80;
	}



	// drive backwards
    	while(SensorValue[rightDrive] > -100)
	{

		motor[frontLeftMotor] = -120;
		motor[backLeftMotor] = -120;
		motor[frontRightMotor] = -106;
		motor[backRightMotor] = -106;


//lift goal even more
		if (SensorValue[rightMobile] > -2000)
		{
		motor[mobileLeftMotor] = -127;
    motor[mobileRightMotor] = -127;

    motor[coneRightMotor] = (-110);
    motor[coneLeftMotor]  = (-110);

		}

		else {
		motor[mobileLeftMotor] = 0;
    motor[mobileRightMotor] = 0;


	}
// grip goal
		motor[mobileClawMotor] = -60;

	}

	// stop and raise
		motor[frontLeftMotor] = 0;
		motor[backLeftMotor] = 0;
		motor[frontRightMotor] = 0;
		motor[backRightMotor] = 0;
		motor[coneRightMotor] = (127);
    motor[coneLeftMotor]  = (127);
    motor[coneClawMotor] = -127;

    motor[mobileLeftMotor] = 0;
    motor[mobileRightMotor] = 0;


    // rotate to score
	while(SensorValue[rightDrive] < 280)
	{
		motor[coneRightMotor] = (127);
    motor[coneLeftMotor]  = (127);
		motor[frontLeftMotor] = -127;
		motor[backLeftMotor] = -127;
		motor[frontRightMotor] = 127;
		motor[backRightMotor] = 127;
	}


	// forward over bar
	  while(SensorValue[rightDrive] < 800)
	{

		motor[frontLeftMotor] = 127;
		motor[backLeftMotor] = 127;
		motor[frontRightMotor] = 127;
		motor[backRightMotor] = 127;

		motor[coneRightMotor] = (127);
    motor[coneLeftMotor]  = (127);

		motor[mobileClawMotor] = 127;
	}

		motor[frontLeftMotor] = 0;
		motor[backLeftMotor] = 0;
		motor[frontRightMotor] = 0;
		motor[backRightMotor] = 0;

		// lift to dump goal
		while(SensorValue[rightMobile] > -2800)
	{

		motor[mobileLeftMotor] = -127;
    motor[mobileRightMotor] = -127;
		motor[mobileClawMotor] = 127;
	}

	motor[mobileLeftMotor] = 0;
  motor[mobileRightMotor] = 0;

  motor[coneLeftMotor] = 0;
  motor[coneRightMotor] = 0;

  // drive backwards
  while(SensorValue[rightDrive] > 250)
	{

		motor[frontLeftMotor] = -127;
		motor[backLeftMotor] = -127;
		motor[frontRightMotor] = -127;
		motor[backRightMotor] = -127;
		motor[mobileClawMotor] = 127;
	}

		motor[frontLeftMotor] = 0;
		motor[backLeftMotor] = 0;
		motor[frontRightMotor] = 0;
		motor[backRightMotor] = 0;

	motor[mobileLeftMotor] = 0;
  motor[mobileRightMotor] = 0;
}


/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	// User control code here, inside the loop

	SensorValue[rightDrive] = 0;	  // Set the encoder so that it starts counting at 0
	SensorValue[leftDrive]  = 0;	  // Set the encoder so that it starts counting at 0

	SensorValue[rightMobile] = 0;	  // Set the encoder so that it starts counting at 0
	SensorValue[leftMobile]  = 0;	  // Set the encoder so that it starts counting at 0

	while (true)
	{


    //Right side of the robot is controlled by the right joystick, Y-axis
    motor[frontRightMotor] = vexRT[Ch2];
    motor[backRightMotor]  = vexRT[Ch2];
    //Left side of the robot is controlled by the left joystick, Y-axis
    motor[frontLeftMotor] = vexRT[Ch3];
    motor[backLeftMotor]  = vexRT[Ch3];


		//motor[frontLeftMotor]  = (vexRT[Ch3] + vexRT[Ch4])/1;  // (y + x)/2
		//motor[backLeftMotor]  = (vexRT[Ch3] + vexRT[Ch4])/1; // (y + x)/2
		//motor[frontRightMotor] = (vexRT[Ch3] - vexRT[Ch4])/1; // (y - x)/2
		//motor[backRightMotor] = (vexRT[Ch3] - vexRT[Ch4])/1; // (y - x)/2

    // Control speeds from variable to make changes easier
    int mobileSpeed = 127;
    int towerSpeed = 127;
    int clawSpeed = 127;



	  //Tower Cone Control
    // Slow dowm motors
    if(vexRT[Btn6D] == 1)
    {
      motor[coneRightMotor] = towerSpeed;
      motor[coneLeftMotor] = towerSpeed;
    }
    else if(vexRT[Btn6U] == 1)
    {
      motor[coneRightMotor] = (-1)*(towerSpeed);
      motor[coneLeftMotor] = (-1)*(towerSpeed);
    }
    else
    {
      motor[coneRightMotor] = 0;
      motor[coneLeftMotor] = 0;
    }

    //Mobile Goal Control

    // endcoder
    // + down
    // - up

    int rightInverse = (SensorValue[rightMobile])*-1;
    int leftInverse = (SensorValue[leftMobile])*-1;

   // int difference = ((SensorValue[rightMobile] - SensorValue[leftMobile])*(SensorValue[rightMobile] - SensorValue[leftMobile]))/3;
    int difference = 0;

    if(vexRT[Btn5D] == 1)
    {

   // if(SensorValue[rightMobile] < 200) {

    if(SensorValue[rightInverse] == SensorValue[leftInverse]) // If rightEncoder has counted the same amount as leftEncoder:
		{
			// Move Forward
		motor[mobileLeftMotor] = mobileSpeed;
    motor[mobileRightMotor] = mobileSpeed;		    // Left Motor is run at power level 80
		}
		else if(SensorValue[rightInverse] > SensorValue[leftInverse])	// If rightEncoder has counted more encoder counts
		{
			// Turn slightly right
			motor[mobileLeftMotor] = mobileSpeed;
    	motor[mobileRightMotor] = mobileSpeed-difference;	    // Left Motor is run at power level 80
		}
		else	// Only runs if leftEncoder has counted more encoder counts
		{
			// Turn slightly left
			motor[mobileLeftMotor] = mobileSpeed-difference;
    	motor[mobileRightMotor] = mobileSpeed;		    // Left Motor is run at power level 60
		}

   // }

   // else {
  //  	if(vexRT[Btn7D] == 1)
  //  {
 // 	  motor[mobileLeftMotor] = 127;
 //     motor[mobileRightMotor] = 127;
 // }
 // }
  }
    else if(vexRT[Btn5U] == 1)
    {
   // if(SensorValue[rightMobile] > -2200) {

    if(SensorValue[rightMobile] == SensorValue[leftMobile]) // If rightEncoder has counted the same amount as leftEncoder:
		{
			// Move Forward
		motor[mobileLeftMotor] = -1*mobileSpeed;
    motor[mobileRightMotor] = -1*mobileSpeed;		    // Left Motor is run at power level 80
		}
		else if(SensorValue[rightMobile] > SensorValue[leftMobile])	// If rightEncoder has counted more encoder counts
		{
			// Turn slightly right
			motor[mobileLeftMotor] = -1*(mobileSpeed);
    	motor[mobileRightMotor] = -1*(mobileSpeed-difference);	    // Left Motor is run at power level 80
		}
		else	// Only runs if leftEncoder has counted more encoder counts
		{
			// Turn slightly left
			motor[mobileLeftMotor] = -1*(mobileSpeed-difference);
    	motor[mobileRightMotor] = -1*(mobileSpeed);		    // Left Motor is run at power level 60
		}

    }

//    else {
//    	if(vexRT[Btn7U] == 1)
//    {
//  	  motor[mobileLeftMotor] = -127;
//      motor[mobileRightMotor] = -127;
//  }
  //}

 //   }
    else
    {
      motor[mobileLeftMotor] = 0;
      motor[mobileRightMotor] = 0;
    }

    if(vexRT[Btn7L] == 1)
    {
      motor[mobileLeftMotor] = clawSpeed;
    }
    if(vexRT[Btn7R] == 1)
    {
      motor[mobileRightMotor] = clawSpeed;
    }

    //Claw Motor

    int clawDirection;

    if(vexRT[Btn8D] == 1)
    {
    	clawDirection = 0;
      motor[coneClawMotor] = clawSpeed;
    }
    else if(vexRT[Btn8U] == 1)
    {
    	clawDirection = 1;
      motor[coneClawMotor] = (-1)*(clawSpeed);
    }
    else
    {
    	if (clawDirection == 1) {
    		motor[coneClawMotor] = -20;
    }
    else {
      motor[coneClawMotor] = 25;
    }
  }



    if(vexRT[Btn8R] == 1)
    {
      motor[mobileClawMotor] = clawSpeed;
    }
    else if((vexRT[Btn8L] == 1) || (vexRT[Btn7U] == 1))
    {
      motor[mobileClawMotor] = (-1)*(clawSpeed);
    }
    else
    {
      motor[mobileClawMotor] = 0;
    }



	}
}
