#pragma config(Sensor, in7,    leftArmSensor,  sensorPotentiometer)
#pragma config(Sensor, in8,    rightArmSensor, sensorPotentiometer)
#pragma config(Motor,  port1,           backLeftMotor, tmotorVex393, openLoop)
#pragma config(Motor,  port2,           frontLeftMotor, tmotorVex393, openLoop)
#pragma config(Motor,  port3,           frontRightMotor, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port4,           backRightMotor, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port5,           leftCollector, tmotorVex393, openLoop)
#pragma config(Motor,  port6,           rightCollector, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port7,           leftArmMotor,  tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port8,           rightArmMotor, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port9,           testing,       tmotorVex393, openLoop)
#pragma config(Motor,  port10,          sidewaysMotor, tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
	V5.1 changelog: autonomous
*/
#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(105)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
int lArm = SensorValue[leftArmSensor] - 567;
int rArm = (-SensorValue[rightArmSensor] + 1770);
int speed = abs((SensorValue[leftArmSensor] - 567) - (-SensorValue[rightArmSensor] + 1770));
void forwardA()
{
	motor[frontLeftMotor] = 70;
  motor[frontRightMotor] = 60;
  motor[backLeftMotor] = 70;
  motor[backRightMotor] = 60;
}
void backwardA()
{
	motor[frontLeftMotor] = -70;
  motor[frontRightMotor] = -60;
  motor[backLeftMotor] = -70;
  motor[backRightMotor] = -60;
}
void counterClockwiseRotationOneSide()
{
	motor[frontRightMotor] = 60;
	motor[backRightMotor] = 60;
}
void counterClockwiseRotationBothSide()
{
	motor[frontLeftMotor] = -70;
  motor[frontRightMotor] = 60;
  motor[backLeftMotor] = -70;
  motor[backRightMotor] = 60;
}
void rest()
{
	motor[frontLeftMotor] = 0;
  motor[frontRightMotor] = 0;
  motor[backLeftMotor] = 0;
  motor[backRightMotor] = 0;
}
void armUp()
{
	if(SensorValue[leftArmSensor] - 567 == (-SensorValue[rightArmSensor] + 1770))
    	{
   			motor[rightArmMotor] = 127;
   			motor[leftArmMotor] = 127;
   		}
  else if(SensorValue[leftArmSensor] - 567 > (-SensorValue[rightArmSensor] + 1770))
   		{
   				motor[rightArmMotor] = 127;
   				motor[leftArmMotor] = 127-abs((SensorValue[leftArmSensor] - 567) - (-SensorValue[rightArmSensor] + 1770));
    	}
  else if(SensorValue[leftArmSensor] - 567 < (-SensorValue[rightArmSensor] + 1770))
    	{
   				motor[rightArmMotor] = 127-abs((SensorValue[leftArmSensor] - 567) - (-SensorValue[rightArmSensor] + 1770));
   				motor[leftArmMotor] = 127;
    	}
}
void intake()
{
	motor[leftCollector] = 127;
	motor[rightCollector] = 127;
}
void outtake()
{
	motor[leftCollector] = -127;
	motor[rightCollector] = -127;
}
void stopTaking()
{
	motor[leftCollector] = 0;
	motor[rightCollector] = 0;
}
void armStop()
{
	motor[rightArmMotor] = 0;
	motor[leftArmMotor] = 0;
}
void armDown()
{
		if(SensorValue[leftArmSensor] - 567 == (-SensorValue[rightArmSensor] + 1770))
    	{
   			motor[rightArmMotor] = -127;
   			motor[leftArmMotor] = -127;
   		}
  else if(SensorValue[leftArmSensor] - 567 > (-SensorValue[rightArmSensor] + 1770))
   		{
   			motor[rightArmMotor] = -127+abs((SensorValue[leftArmSensor] - 567) - (-SensorValue[rightArmSensor] + 1770));
   			motor[leftArmMotor] = -127;

    	}
  else if(SensorValue[leftArmSensor] - 567 < (-SensorValue[rightArmSensor] + 1770))
    	{
   				motor[rightArmMotor] = -127;
   				motor[leftArmMotor] = -127+abs((SensorValue[leftArmSensor] - 567) - (-SensorValue[rightArmSensor] + 1770));
    	}
}
void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}
task autonomous()
{
	while(SensorValue[leftArmSensor]<740&&SensorValue[rightArmSensor]>1500)
	{
		armUp();
	}
		armStop();
	while(SensorValue[leftArmSensor] > 662 || SensorValue[rightArmSensor] < 1684)
    	{
    		armDown();
    	}
  while(SensorValue[leftArmSensor] < 662 || SensorValue[rightArmSensor] > 1684)
    	{
    		armUp();
    	}
  while(SensorValue[leftArmSensor] == 662 || SensorValue[rightArmSensor] == 1684)
    	{
    		armStop();
    	}
  ClearTimer(T1);
  while(time1[T1]<100)
	{
		rest();
	}
	ClearTimer(T1);
  while(time1[T1]<2050)
	{
		forwardA();
		intake();
	}
	ClearTimer(T1);
	while(time1[T1] < 200)
	{
		rest();
	}
	ClearTimer(T1);
	while(time1[T1] < 1500)
	{
		backwardA();
	}
	rest();
	ClearTimer(T1);
	while(time1[T1]<=350)
	{
		motor[sidewaysMotor] = -127;
	}
	motor[sidewaysMotor] = 0;
	rest();
	ClearTimer(T1);
	while(time1[T1]<625)
	{
		counterClockwiseRotationBothSide();
	}
	rest();
	ClearTimer(T1);
	while(time1[T1]<1000)
	{
		forwardA();
	}
	rest();
	while(SensorValue[leftArmSensor] < 1938 || SensorValue[rightArmSensor] > 382)
	{
		armUp();
	}
	armStop();
	ClearTimer(T1);
	while(time1[T1] < 300)
	{
		forwardA();
	}
	rest();
	ClearTimer(T1);
	while(time1[T1] < 1500)
	{
		motor[sidewaysMotor] = 127;
	}
	motor[sidewaysMotor] = 0;
	ClearTimer(T1);
	while(time1[T1] < 300)
	{
		forwardA();
	}
	rest();
	ClearTimer(T1);
	while(time1[T1] < 600)
	{
		forwardA();
	}
	rest();
	ClearTimer(T1);
	while(time1(T1)<1500)
	{
		outtake();
	}
	rest();
	stopTaking();
	ClearTimer(T1);
	while(time1[T1] < 400)
	{
		backwardA();
	}
	ClearTimer(T1);
	while(time1[T1] < 400)
	{
		forwardA();
	}
	rest();
	ClearTimer(T1);
	while(time1[T1] < 1500)
	{
		outtake();
	}
	stopTaking();
}

task usercontrol()
{
	// User control code here, inside the loop

	while (true)
	{
	  int side = 0;
		int forbackward = 0;
		int threshold1 = 63;
		int threshold2 = 30;
		int lArm = SensorValue[leftArmSensor] - 618;
		int rArm = (-SensorValue[rightArmSensor] + 1770);
		int speed = abs(lArm - rArm);


  	if(abs(vexRT[Ch4]) > threshold1)
  	{
  		side = vexRT[Ch4];
  	}
  	else
  	{
  		side = 0;
  	}
  	if (abs(vexRT[Ch3]) > threshold2)
  	{
  		forbackward = vexRT[Ch3];
  	}
  	else
  	{
  		forbackward = 0;
  	}

 		//Right side of the robot is controlled by the left joystick, Y-axis, minus the rotation from the x axis
    motor[frontRightMotor] = (forbackward - vexRT[Ch1]/2);
    motor[backRightMotor]  = (forbackward - vexRT[Ch1]/2);
    //Left side of the robot is controlled by the left joystick, Y-axis, plus the rotation from the x axis
    motor[frontLeftMotor] = (forbackward + vexRT[Ch1]/2);
    motor[backLeftMotor]  = (forbackward + vexRT[Ch1]/2);

    motor[sidewaysMotor] = side; // Allows the robot to move sideways, based on the


    //six bar control.
    if(SensorValue[leftArmSensor] > 535 && SensorValue[rightArmSensor] < 1809 && SensorValue[leftArmSensor] < 2046 && SensorValue[rightArmSensor] > 242)
    {
  		//six bar seperately control
  		if(vexRT[Btn8U] == 1 && vexRT[Btn8D] == 1)
    	{
    		if(vexRT[Btn5U] == 1)
    			motor[leftArmMotor] = 127;
    		else if(vexRT[Btn5D] == 1)
    			motor[leftArmMotor] = -127;
    		else
    			motor[leftArmMotor] = 0;
    		if(vexRT[Btn6U] == 1)
    			motor[rightArmMotor] = 127;
    		else if(vexRT[Btn6D] == 1)
    			motor[rightArmMotor] = -127;
    		else
    			motor[rightArmMotor] = 0;
  		}
  		//six bar collaboratively control.
    	else if(lArm == rArm)
    	{
   			if(vexRT[Btn6U] == 1)
   			{
   				motor[rightArmMotor] = 127;
   				motor[leftArmMotor] = 127;
   			}
   			else	if(vexRT[Btn6D] == 1)
   			{
   				motor[rightArmMotor] = -127;
   				motor[leftArmMotor] = -127;
   			}
   			else
   			{
   				motor[rightArmMotor] = 0;
   				motor[leftArmMotor] = 0;
   			}
   		}
   		else if(lArm > rArm)
   		{
   			if(vexRT[Btn6U] == 1)
   			{
   				motor[rightArmMotor] = 127;
   				motor[leftArmMotor] = 127-speed;
   			}
   			else if(vexRT[Btn6D] == 1)
   			{
   				motor[rightArmMotor] = -127+speed;
   				motor[leftArmMotor] = -127;
   			}
   			else
   			{
   				motor[rightArmMotor] = 0;
   				motor[leftArmMotor] = 0;
   	  	}
    	}
    	else if(lArm < rArm)
    	{
    		if(vexRT[Btn6U] == 1)
   			{
   				motor[rightArmMotor] = 127-speed;
   				motor[leftArmMotor] = 127;
   			}
   			else if(vexRT[Btn6D] == 1)
   			{
   				motor[rightArmMotor] = -127;
   				motor[leftArmMotor] = -127+speed;
   			}
   			else
   			{
   				motor[rightArmMotor] = 0;
   				motor[leftArmMotor] = 0;
   	  	}
    	}
    }
    //lower than starting position.
    else if(SensorValue[leftArmSensor] < 535 || SensorValue[rightArmSensor] > 1809)
    {
    	if(vexRT[Btn8U] == 1 && vexRT[Btn8D] == 1)
    	{
    		if(vexRT[Btn5U] == 1)
    			motor[leftArmMotor] = 127;
    		else
    			motor[leftArmMotor] = 0;
    		if(vexRT[Btn6U] == 1)
    			motor[rightArmMotor] = 127;
    		else
    			motor[rightArmMotor] = 0;
  		}
    	else if(lArm == rArm)
    	{
   			if(vexRT[Btn6U] == 1)
   			{
   				motor[rightArmMotor] = 127;
   				motor[leftArmMotor] = 127;
   			}
   			else
   			{
   				motor[rightArmMotor] = 0;
   				motor[leftArmMotor] = 0;
   			}
   		}
   		else if(lArm > rArm)
   		{
   			if(vexRT[Btn6U] == 1)
   			{
   				motor[rightArmMotor] = 127;
   				motor[leftArmMotor] = 127-speed;
   			}
   			else
   			{
   				motor[rightArmMotor] = 0;
   				motor[leftArmMotor] = 0;
   	  	}
    	}
    	else if(lArm < rArm)
    	{
    		if(vexRT[Btn6U] == 1)
   			{
   				motor[rightArmMotor] = 127-speed;
   				motor[leftArmMotor] = 127;
   			}
   			else
   			{
   				motor[rightArmMotor] = 0;
   				motor[leftArmMotor] = 0;
   	  	}
    	}
    }
    //higher than highest position.
    else if(SensorValue[leftArmSensor] > 2046 || SensorValue[rightArmSensor] < 242)
    {
    	if(vexRT[Btn8U] == 1 && vexRT[Btn8D] == 1)
    	{
    		if(vexRT[Btn5D] == 1)
    			motor[leftArmMotor] = -127;
    		else
    			motor[leftArmMotor] = 0;
    		if(vexRT[Btn6D] == 1)
    			motor[rightArmMotor] = -127;
    		else
    			motor[rightArmMotor] = 0;
  		}
    	else if(lArm == rArm)
    	{
   			if(vexRT[Btn6D] == 1)
   			{
   				motor[rightArmMotor] = -127;
   				motor[leftArmMotor] = -127;
   			}
   			else
   			{
   				motor[rightArmMotor] = 0;
   				motor[leftArmMotor] = 0;
   			}
   		}
   		else if(lArm > rArm)
   		{
   			if(vexRT[Btn6D] == 1)
   			{
   				motor[rightArmMotor] = -127+speed;
   				motor[leftArmMotor] = -127;
   			}
   			else
   			{
   				motor[rightArmMotor] = 0;
   				motor[leftArmMotor] = 0;
   	  	}
    	}
    	else if(lArm < rArm)
    	{
    		if(vexRT[Btn6D] == 1)
   			{
   				motor[rightArmMotor] = -127;
   				motor[leftArmMotor] = -127+speed;
   			}
   			else
   			{
   				motor[rightArmMotor] = 0;
   				motor[leftArmMotor] = 0;
   	  	}
    	}
    }
		if(vexRT[Btn8R] == 1)
		{
    	if(SensorValue[leftArmSensor] < 662 || SensorValue[rightArmSensor] > 1684)
    	{
    		armUp();
    	}
    	else if(SensorValue[leftArmSensor] == 662 || SensorValue[rightArmSensor] == 1684)
    	{
    		armStop();
    	}
    }
    //convey and collector
    if(vexRT[Btn5U] == 1)
    {
    	motor[leftCollector] = 127;
    	motor[rightCollector] = 127;
    }
    else if(vexRT[Btn5D] == 1)
    {
    	motor[leftCollector] = -127;
    	motor[rightCollector] = -127;
    }
    else
    {
    	motor[leftCollector] = 0;
    	motor[rightCollector] = 0;
    }
	}
}
