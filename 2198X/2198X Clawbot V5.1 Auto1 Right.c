#pragma config(Sensor, in1,    armSensor,      sensorPotentiometer)
#pragma config(Sensor, in2,    clawSensor,     sensorPotentiometer)
#pragma config(Sensor, dgtl1,  leftWheels,     sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightWheels,    sensorQuadEncoder)
#pragma config(Motor,  port1,           leftMotor1,    tmotorVex393, openLoop)
#pragma config(Motor,  port2,           leftMotor3,    tmotorVex393, openLoop)
#pragma config(Motor,  port3,           rightMotor4,   tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port4,           rightMotor5,   tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port5,           rightMotor6,   tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port6,           claw,          tmotorVex393, openLoop)
#pragma config(Motor,  port7,           leftTower,     tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port8,           rightTower,    tmotorVex393, openLoop)
#pragma config(Motor,  port9,           lock,          tmotorServoStandard, openLoop)
#pragma config(Motor,  port10,          leftMotor2,    tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
changelog: V5.0: add mecanum wheels control, left joystick forward & sideway, right joystick rotation..
*/
#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(105)

void forwardAuto(int speed)//distance in positive, remember to set sensor value to zero if needed; speed in positive
{
		if(SensorValue[leftWheels] > SensorValue[rightWheels])
		{
			motor[leftMotor1] = speed - (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[leftMotor2] = speed - (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[leftMotor3] = speed - (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[rightMotor4] = speed;
			motor[rightMotor5] = speed;
			motor[rightMotor6] = speed;
		}
		else if(SensorValue[leftWheels] < SensorValue[rightWheels])
		{
			motor[leftMotor1] = speed;
			motor[leftMotor2] = speed;
			motor[leftMotor3] = speed;
			motor[rightMotor4] = speed - (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[rightMotor5] = speed - (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[rightMotor6] = speed - (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
		}
		else if(SensorValue[leftWheels] == SensorValue[rightWheels])
		{
			motor[leftMotor1] = speed;
			motor[leftMotor2] = speed;
			motor[leftMotor3] = speed;
			motor[rightMotor4] = speed;
			motor[rightMotor5] = speed;
			motor[rightMotor6] = speed;
		}
}

void backwardAuto(int speed)//distance in negative, remember to set sensor value to zero if needed; speed in positive
{
		if(SensorValue[leftWheels] > SensorValue[rightWheels])
		{
			motor[leftMotor1] = -speed;
			motor[leftMotor2] = -speed;
			motor[leftMotor3] = -speed;
			motor[rightMotor4] = -speed + (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[rightMotor5] = -speed + (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[rightMotor6] = -speed + (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
		}
		else if(SensorValue[leftWheels] < SensorValue[rightWheels])
		{
			motor[leftMotor1] = -speed + (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[leftMotor2] = -speed + (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[leftMotor3] = -speed + (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[rightMotor4] = -speed;
			motor[rightMotor5] = -speed;
			motor[rightMotor6] = -speed;
		}
		else if(SensorValue[leftWheels] == SensorValue[rightWheels])
		{
			motor[leftMotor1] = -speed;
			motor[leftMotor2] = -speed;
			motor[leftMotor3] = -speed;
			motor[rightMotor4] = -speed;
			motor[rightMotor5] = -speed;
			motor[rightMotor6] = -speed;
		}
}

void ccwRotationBothSide(int degree, int speed)//degree in positive, and speed in positive for both side, program will set them to negative
{
	int distance = 7.5*degree/2;
	while(SensorValue[leftWheels] > -distance && SensorValue[rightWheels] < distance)
	{
		motor[leftMotor1] = -speed;
		motor[leftMotor2] = -speed;
		motor[leftMotor3] = -speed;
		motor[rightMotor4] = speed;
		motor[rightMotor5] = speed;
		motor[rightMotor6] = speed;
	}
}

void cwRotationBothSide(int degree,int speed)//degree in positive, and speed in positive for both side, program will set them to negative
{
	int distance = 7.5*degree/2;
	while(SensorValue[leftWheels] < distance && SensorValue[rightWheels] > -distance)
	{
		motor[leftMotor1] = speed;
		motor[leftMotor2] = speed;
		motor[leftMotor3] = speed;
		motor[rightMotor4] = -speed;
		motor[rightMotor5] = -speed;
		motor[rightMotor6] = -speed;
	}
}

void stopMoving()
{
	motor[leftMotor1] = 0;
	motor[leftMotor2] = 0;
	motor[leftMotor3] = 0;
	motor[rightMotor4] = 0;
	motor[rightMotor5] = 0;
	motor[rightMotor6] = 0;
}

void armUp()
{
	motor[leftTower] = 127;
	motor[rightTower] = 127;
}

void armDown()
{
	motor[leftTower] = -40;
	motor[rightTower] = -40;
}

void hanging()
{
	motor[leftTower] = -127;
	motor[rightTower] = -127;
}

void armStop()
{
	if(SensorValue[armSensor] < 1790 && SensorValue[armSensor] > 140)
	{
		motor[leftTower] = 15;
		motor[rightTower] = 15;
	}
	else
	{
		motor[leftTower] = 0;
		motor[rightTower] = 0;
	}
}


void defenseAuto()
{
	int clawAuto = 0;
	if(SensorValue[clawSensor] < 2000)
		clawAuto = 1;
	else if(SensorValue[clawSensor] >2000 && SensorValue[clawSensor] < 2400)
		clawAuto = 2;
	else if(SensorValue[clawSensor] >2400 && SensorValue[clawSensor] < 2450)
		clawAuto = 0;
	else if(SensorValue[clawSensor] >2450 && SensorValue[clawSensor] < 2900)
		clawAuto = 3;
	else if(SensorValue[clawSensor] >2900)
		clawAuto = 4;
	while(clawAuto == 1)
	{
		motor[claw] = 75;
		motor[leftMotor1] = 0 - SensorValue[leftWheels];
		motor[leftMotor2] = 0 - SensorValue[leftWheels];
		motor[leftMotor3] = 0 - SensorValue[leftWheels];
		motor[rightMotor4] = 0 - SensorValue[rightWheels];
		motor[rightMotor5] = 0 - SensorValue[rightWheels];
		motor[rightMotor6] = 0 - SensorValue[rightWheels];
		int clawAuto = 0;
		if(SensorValue[clawSensor] < 2000)
			clawAuto = 1;
		else if(SensorValue[clawSensor] >2000 && SensorValue[clawSensor] < 2400)
			clawAuto = 2;
		else if(SensorValue[clawSensor] >2400 && SensorValue[clawSensor] < 2500)
			clawAuto = 0;
		else if(SensorValue[clawSensor] >2450 && SensorValue[clawSensor] < 2900)
			clawAuto = 3;
		else if(SensorValue[clawSensor] >2900)
			clawAuto = 4;
	}
	while(clawAuto == 2)
	{
		motor[claw] = 40;
		motor[leftMotor1] = 0 - SensorValue[leftWheels];
		motor[leftMotor2] = 0 - SensorValue[leftWheels];
		motor[leftMotor3] = 0 - SensorValue[leftWheels];
		motor[rightMotor4] = 0 - SensorValue[rightWheels];
		motor[rightMotor5] = 0 - SensorValue[rightWheels];
		motor[rightMotor6] = 0 - SensorValue[rightWheels];
		if(SensorValue[clawSensor] < 2000)
			clawAuto = 1;
		else if(SensorValue[clawSensor] >2000 && SensorValue[clawSensor] < 2400)
			clawAuto = 2;
		else if(SensorValue[clawSensor] >2400 && SensorValue[clawSensor] < 2500)
			clawAuto = 0;
		else if(SensorValue[clawSensor] >2450 && SensorValue[clawSensor] < 2900)
			clawAuto = 3;
		else if(SensorValue[clawSensor] >2900)
			clawAuto = 4;
	}
	while(clawAuto == 3)
	{
		motor[claw] = -20;
		motor[leftMotor1] = 0 - SensorValue[leftWheels];
		motor[leftMotor2] = 0 - SensorValue[leftWheels];
		motor[leftMotor3] = 0 - SensorValue[leftWheels];
		motor[rightMotor4] = 0 - SensorValue[rightWheels];
		motor[rightMotor5] = 0 - SensorValue[rightWheels];
		motor[rightMotor6] = 0 - SensorValue[rightWheels];
		if(SensorValue[clawSensor] < 2000)
			clawAuto = 1;
		else if(SensorValue[clawSensor] >2000 && SensorValue[clawSensor] < 2400)
			clawAuto = 2;
		else if(SensorValue[clawSensor] >2400 && SensorValue[clawSensor] < 2500)
			clawAuto = 0;
		else if(SensorValue[clawSensor] >2450 && SensorValue[clawSensor] < 2900)
			clawAuto = 3;
		else if(SensorValue[clawSensor] >2900)
			clawAuto = 4;
	}
	while(clawAuto == 4)
	{
		motor[claw] = -75;
		motor[leftMotor1] = 0 - SensorValue[leftWheels];
		motor[leftMotor2] = 0 - SensorValue[leftWheels];
		motor[leftMotor3] = 0 - SensorValue[leftWheels];
		motor[rightMotor4] = 0 - SensorValue[rightWheels];
		motor[rightMotor5] = 0 - SensorValue[rightWheels];
		motor[rightMotor6] = 0 - SensorValue[rightWheels];
		if(SensorValue[clawSensor] < 2000)
			clawAuto = 1;
		else if(SensorValue[clawSensor] >2000 && SensorValue[clawSensor] < 2400)
			clawAuto = 2;
		else if(SensorValue[clawSensor] >2400 && SensorValue[clawSensor] < 2500)
			clawAuto = 0;
		else if(SensorValue[clawSensor] >2450 && SensorValue[clawSensor] < 2900)
			clawAuto = 3;
		else if(SensorValue[clawSensor] >2900)
			clawAuto = 4;
	}
	while(clawAuto == 0)
	{
		motor[claw] = 0;
		motor[leftMotor1] = 0 - SensorValue[leftWheels];
		motor[leftMotor2] = 0 - SensorValue[leftWheels];
		motor[leftMotor3] = 0 - SensorValue[leftWheels];
		motor[rightMotor4] = 0 - SensorValue[rightWheels];
		motor[rightMotor5] = 0 - SensorValue[rightWheels];
		motor[rightMotor6] = 0 - SensorValue[rightWheels];
		if(SensorValue[clawSensor] < 2000)
			clawAuto = 1;
		else if(SensorValue[clawSensor] >2000 && SensorValue[clawSensor] < 2400)
			clawAuto = 2;
		else if(SensorValue[clawSensor] >2400 && SensorValue[clawSensor] < 2500)
			clawAuto = 0;
		else if(SensorValue[clawSensor] >2450 && SensorValue[clawSensor] < 2900)
			clawAuto = 3;
		else if(SensorValue[clawSensor] >2900)
			clawAuto = 4;
	}
}

void openClaw()
{
	motor[claw] = 63;
}
void clawBackToPosition()
{
	motor[claw] = -127;
}
void closeClaw()
{
	motor[claw] = -63;
}

void holdClaw()
{
	motor[claw] = -40;
}

void clawStop()
{
	if(SensorValue[clawSensor] < 1110)
		motor[claw] = 127;
	else if(SensorValue[clawSensor] > 1100 && SensorValue[clawSensor] < 1570)
		motor[claw] = 40;
	else if(SensorValue[clawSensor] > 1570 && SensorValue[clawSensor] < 1670)
		motor[claw] = 20;
	else
		motor[claw] = 0;
}
void clearEncoders()
{
	SensorValue[leftWheels] = 0;
	SensorValue[rightWheels] = 0;
}

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
void pre_auton()
{
	motor[lock] = 127;
	clearEncoders();
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//																																																																															//
//////////////////////////////////////////////////////////////////////Autonomous//////////////////////////////////////////////////////////////////////////////////
//                        																																																																		  //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	int defence = 0;
	pre_auton();
	while(SensorValue[leftWheels] < 60 && SensorValue[rightWheels] < 60)
	{
		forwardAuto(63);
	}
	stopMoving();
	while(SensorValue[leftWheels] > -100 && SensorValue[rightWheels] > -100)
	{
		backwardAuto(63);
		armUp();
	}
	stopMoving();
	while(SensorValue[armSensor] > 1490)
	{
		armUp();
	}
	armStop();
	while(SensorValue(clawSensor) > 1570)
	{
		clawBackToPosition();
	}
	ClearTimer(T1);
	while(time1[T1] < 300)
	{
		clawStop();
	}
	motor[claw] = 20;
	while(SensorValue[armSensor] < 2270)
	{
		armDown();
		forwardAuto(30);
	}
	armStop();
	while(SensorValue[leftWheels] < 580 && SensorValue[rightWheels] < 580)
	{
		forwardAuto(70);
	}
	stopMoving();
	holdClaw();
	wait1Msec(300);
	while(SensorValue(leftWheels) > -110 && SensorValue[rightWheels] > -110)
	{
		backwardAuto(70);
		armUp();
	}
	stopMoving();
	while(SensorValue(armSensor) > 150)
	{
		armUp();
	}
	armStop();
	wait1Msec(150);
	clearEncoders();
	cwRotationBothSide(90,40);
	stopMoving();
	clearEncoders();
	while(SensorValue[leftWheels] < 1380 && SensorValue[rightWheels] < 1380)
	{
		forwardAuto(90);
	}
	stopMoving();
	while(SensorValue[clawSensor] < 1500)
	{
		openClaw();
	}
	while(SensorValue[clawSensor] > 1200)
	{
		closeClaw();
	}
	clawStop();
	while(SensorValue[leftWheels] > 1100 && SensorValue[rightWheels] > 1100)
	{
		backwardAuto(90);
	}
	stopMoving();
	while(SensorValue[armSensor] < 450)
	{
		armDown();
		openClaw();
	}
	armStop();
	while(SensorValue[leftWheels] < 1375 && SensorValue[rightWheels] < 1375 && SensorValue[clawSensor] < 2400)
	{
		openClaw();
		forwardAuto(45);
	}
	clawStop();
	while(SensorValue[leftWheels] < 1475 && SensorValue[rightWheels] < 1475)
	{
		forwardAuto(90);
	}
	stopMoving();
	wait1Msec(200);
	clearEncoders();
	while(true)
	{
		defenseAuto();
	}
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//																																																																															//
////////////////////////////////////////////////////////////////////Driver Control////////////////////////////////////////////////////////////////////////////////
//                        																																																																		  //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	while (true)
	{
			//driving system
		int threshold1;
		int threshold3;
		int threshold4;
		if(abs(vexRT[Ch1]) > 30)
			threshold1 = vexRT[Ch1];
		else
			threshold1 = 0;
		if (abs(vexRT[Ch3]) > 30)
			threshold3 = vexRT[Ch3];
		else
			threshold3 = 0;
		if (abs(vexRT[Ch4]) > 30)
			threshold4 = vexRT[Ch4];
		else
			threshold4 = 0;
		if(vexRT[Btn8D] == 1 || vexRT[Btn7D] == 1)//precise control
		{
			motor[leftMotor1] = threshold3/2.5 + threshold1/4 - threshold4/2;
			motor[leftMotor2] = threshold3/2.5 + threshold1/4;
			motor[leftMotor3] = threshold3/2.5 + threshold1/4 + threshold4/5;
			motor[rightMotor4] = threshold3/2.5 - threshold1/4;
			motor[rightMotor5] = threshold3/2.5 - threshold1/4 + threshold4/2;
			motor[rightMotor6] = threshold3/2.5 - threshold1/4 - threshold4/5;
		}
		else//fast moving controlkidding
		{
			motor[leftMotor1] = threshold3 + threshold1/2 - threshold4;
			motor[leftMotor2] = threshold3 + threshold1/2;
			motor[leftMotor3] = threshold3 + threshold1/2 + threshold4/2.5;
			motor[rightMotor4] = threshold3 - threshold1/2;
			motor[rightMotor5] = threshold3 - threshold1/2 + threshold4;
			motor[rightMotor6] = threshold3 - threshold1/2 - threshold4/2.5;
		}


		//six bar control.
		if(vexRT[Btn8U] != 1 && vexRT[Btn8R] != 1 && vexRT[Btn7R] != 1)
		{
			if(SensorValue[armSensor] > 220  && SensorValue[armSensor] < 2064 )
			{
				if(vexRT[Btn5U] == 1)
				{
					armUp();
				}
				else	if(vexRT[Btn5D] == 1)
					armDown();
				else
					armStop();
			}
		//goes up from the lowest position.
		else if(SensorValue[armSensor] > 2064)
   	{
   		if(vexRT[Btn5U] == 1)
   			armUp();
   		else
 				armStop();
   	}
    //goes down from the highest position
    else if(SensorValue[armSensor]< 220)
    {
 			if(vexRT[Btn5D] == 1)
 				armDown();
   		else
   			armStop();
   	}
  	}
   	else if(vexRT[Btn8U] == 1 && vexRT[Btn8R] != 1 && vexRT[Btn7R] != 1)
  	{
  		if(SensorValue[armSensor] >545)
				armUp();
			else if(SensorValue[armSensor] < 545 && SensorValue[armSensor] > 475)
				armStop();
			else if(SensorValue[armSensor] < 475)
				armDown();
  	}
  	else if(vexRT[Btn8R] == 1 && vexRT[Btn8U] != 1 && vexRT[Btn7R] != 1)
  	{
  		if(SensorValue[armSensor] > 880)
				armUp();
			else if(SensorValue[armSensor] < 880 && SensorValue[armSensor] > 810)
				armStop();
			else if(SensorValue[armSensor] < 810)
				armDown();
  	}
  	else if(vexRT[Btn7R] == 1)
  		hanging();
  	//lock
		if(vexRT[Btn8L] == 1)
			motor[lock] = -120;
		else if(vexRT[Btn7L] == 1 && vexRT[Btn7U] == 1)
			motor[lock] = 127;
		//claw
    if(vexRT[Btn6U] == 1)
   		holdClaw();
   	else if(vexRT[Btn6D] == 1)
   		openClaw();
   	else
   		clawStop();
	}
}
