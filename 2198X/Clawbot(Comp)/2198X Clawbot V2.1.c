#pragma config(Sensor, in1,    armSensor,      sensorPotentiometer)
#pragma config(Sensor, in2,    clawSensor,     sensorPotentiometer)
#pragma config(Sensor, dgtl1,  leftWheels,     sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightWheels,    sensorQuadEncoder)
#pragma config(Motor,  port1,           leftMotor1,    tmotorVex393, openLoop)
#pragma config(Motor,  port2,           leftMotor3,    tmotorVex393, openLoop)
#pragma config(Motor,  port3,           rightMotor4,   tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port4,           rightMotor5,   tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port5,           rightMotor6,   tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port6,           claw,          tmotorVex393, openLoop)
#pragma config(Motor,  port7,           leftTower,     tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port8,           rightTower,    tmotorVex393, openLoop)
#pragma config(Motor,  port9,           lock,          tmotorServoStandard, openLoop)
#pragma config(Motor,  port10,          leftMotor2,    tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
changelog: V2.0: start autonomous.
*/
#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(105)


void forwardAuto(int distance, int speed)//distance in positive, remember to set sensor value to zero if needed; speed in positive
{
	while(SensorValue[leftWheels] < distance || SensorValue[rightWheels] < distance)
	{
		if(SensorValue[leftWheels] > SensorValue[rightWheels])
		{
			motor[leftMotor1] = speed - (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[leftMotor2] = speed - (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[leftMotor3] = speed - (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[rightMotor4] = speed;
			motor[rightMotor5] = speed;
			motor[rightMotor6] = speed;
		}
		else if(SensorValue[leftWheels] < SensorValue[rightWheels])
		{
			motor[leftMotor1] = speed;
			motor[leftMotor2] = speed;
			motor[leftMotor3] = speed;
			motor[rightMotor4] = speed - (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[rightMotor5] = speed - (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[rightMotor6] = speed - (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
		}
		else if(SensorValue[leftWheels] == SensorValue[rightWheels])
		{
			motor[leftMotor1] = speed;
			motor[leftMotor2] = speed;
			motor[leftMotor3] = speed;
			motor[rightMotor4] = speed;
			motor[rightMotor5] = speed;
			motor[rightMotor6] = speed;
		}
	}
}

void backwardAuto(int distance, int speed)//distance in negative, remember to set sensor value to zero if needed; speed in positive
{
	while(SensorValue[leftWheels] > distance || SensorValue[rightWheels] > distance)
	{
		if(SensorValue[leftWheels] > SensorValue[rightWheels])
		{
			motor[leftMotor1] = -speed;
			motor[leftMotor2] = -speed;
			motor[leftMotor3] = -speed;
			motor[rightMotor4] = -speed + (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[rightMotor5] = -speed + (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[rightMotor6] = -speed + (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
		}
		else if(SensorValue[leftWheels] < SensorValue[rightWheels])
		{
			motor[leftMotor1] = -speed + (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[leftMotor2] = -speed + (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[leftMotor3] = -speed + (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[rightMotor4] = -speed;
			motor[rightMotor5] = -speed;
			motor[rightMotor6] = -speed;
		}
		else if(SensorValue[leftWheels] == SensorValue[rightWheels])
		{
			motor[leftMotor1] = -speed;
			motor[leftMotor2] = -speed;
			motor[leftMotor3] = -speed;
			motor[rightMotor4] = -speed;
			motor[rightMotor5] = -speed;
			motor[rightMotor6] = -speed;
		}
	}
}

void ccwRotationBothSide(int degree, int speed)//degree in positive, and speed in positive for both side, program will set them to negative
{
	int distance = (11*PI*degree)/(4*PI);
	while(SensorValue[leftWheels] > -distance || SensorValue[rightWheels] < distance)
	{
		motor[leftMotor1] = -speed;
		motor[leftMotor2] = -speed;
		motor[leftMotor3] = -speed;
		motor[rightMotor4] = speed;
		motor[rightMotor5] = speed;
		motor[rightMotor6] = speed;
	}
}

void cwRotationBothSide(int degree, int speed)//degree in positive, and speed in positive for both side, program will set them to negative
{
	int distance = (11*PI*degree)/(4*PI);
	while(SensorValue[leftWheels] < distance || SensorValue[rightWheels] > -distance)
	{
		motor[leftMotor1] = speed;
		motor[leftMotor2] = speed;
		motor[leftMotor3] = speed;
		motor[rightMotor4] = -speed;
		motor[rightMotor5] = -speed;
		motor[rightMotor6] = -speed;
	}
}

void stopMoving()
{
	motor[leftMotor1] = 0;
	motor[leftMotor2] = 0;
	motor[leftMotor3] = 0;
	motor[rightMotor4] = 0;
	motor[rightMotor5] = 0;
	motor[rightMotor6] = 0;
}

void defenseAuto()
{
	SensorValue[leftWheels] = 0;
	SensorValue[rightWheels] = 0;
	if(SensorValue[leftWheels] < 0 || SensorValue[rightWheels] < 0)
	{
		if(SensorValue[leftWheels] > SensorValue[rightWheels])
		{
			motor[leftMotor1] = 127 - (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[leftMotor2] = 127 - (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[leftMotor3] = 127 - (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[rightMotor4] = 127;
			motor[rightMotor5] = 127;
			motor[rightMotor6] = 127;
		}
		else if(SensorValue[leftWheels] < SensorValue[rightWheels])
		{
			motor[leftMotor1] = 127;
			motor[leftMotor2] = 127;
			motor[leftMotor3] = 127;
			motor[rightMotor4] = 127 - (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[rightMotor5] = 127 - (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[rightMotor6] = 127 - (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
		}
		else if(SensorValue[leftWheels] == SensorValue[rightWheels])
		{
			motor[leftMotor1] = 127;
			motor[leftMotor2] = 127;
			motor[leftMotor3] = 127;
			motor[rightMotor4] = 127;
			motor[rightMotor5] = 127;
			motor[rightMotor6] = 127;
		}
	}
	else if (SensorValue[leftWheels] > 0 || SensorValue[rightWheels] > 0)
	{
		if(SensorValue[leftWheels] > SensorValue[rightWheels])
		{
			motor[leftMotor1] = -20 - (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[leftMotor2] = -20 - (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[leftMotor3] = -20 - (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[rightMotor4] = -20;
			motor[rightMotor5] = -20;
			motor[rightMotor6] = -20;
		}
		else if(SensorValue[leftWheels] < SensorValue[rightWheels])
		{
			motor[leftMotor1] = -20;
			motor[leftMotor2] = -20;
			motor[leftMotor3] = -20;
			motor[rightMotor4] = -20 - (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[rightMotor5] = -20 - (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
			motor[rightMotor6] = -20 - (abs((SensorValue[leftWheels]) - (SensorValue[rightWheels])));
		}
		else if(SensorValue[leftWheels] == SensorValue[rightWheels])
		{
			motor[leftMotor1] = -20;
			motor[leftMotor2] = -20;
			motor[leftMotor3] = -20;
			motor[rightMotor4] = -20;
			motor[rightMotor5] = -20;
			motor[rightMotor6] = -20;
		}
	}
	else
	{
		motor[leftMotor1] = 0;
		motor[leftMotor2] = 0;
		motor[leftMotor3] = 0;
		motor[rightMotor4] = 0;
		motor[rightMotor5] = 0;
		motor[rightMotor6] = 0;
	}
}

void armUp()
{
	motor[leftTower] = 127;
	motor[rightTower] = 127;
}

void armDown()
{
	motor[leftTower] = -63;
	motor[rightTower] = -63;
}

void armStop()
{
	motor[leftTower] = 0;
	motor[rightTower] =0 ;
}

void grab()
{
	motor[claw] = 127;
}

void holdClaw()
{
	while(true)
	{
		motor[claw] = 40;
		wait1Msec(1);
		motor[claw] = 0;
		wait1Msec(1);
	}
}

void extendClaw()
{
	if(SensorValue[clawSensor] > 1070)
	{
		motor[claw] = 127;
	}
	motor[claw] = 0;
	if(SensorValue[clawSensor] < 1070)
	{
		while(true)
		{
			motor[claw] = 63;
			wait1Msec(1);
			motor[claw] = 0;
			wait1Msec(1);
		}
	}
}

void clearEncoders()
{
	SensorValue[leftWheels] = 0;
	SensorValue[rightWheels] = 0;
}

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
void pre_auton()
{
	motor[lock] = -60;
	clearEncoders();
}
task autonomous()
{
	clearEncoders();
	defenseAuto();
	/*clearEncoders();
	//go right for 12"
	forwardAuto(344,40);
	stopMoving();
	wait1Msec(100);
	clearEncoders();
	//CCW rotation 180 degree
	ccwRotationBothSide(180,40);
	stopMoving();
	wait1Msec(100);
	clearEncoders();
	//CW rotation 180 degree
	cwRotationBothSide(180,40);
	stopMoving();
	clearEncoders();
	//forward 48"
	forwardAuto(1375,40);
	stopMoving();
	wait1Msec(100);
	clearEncoders();
	//defense
	//defenseAuto();
	*/
}
task usercontrol()
{

	while (true)
	{
			//driving system
		int threshold = 0;
		if(abs(vexRT[Ch3]) > 30)
			threshold = vexRT[Ch3];
		else
			threshold = 0;
		if(abs(vexRT[Ch4]) <= 63)
		{
			motor[leftMotor1] = threshold;
			motor[leftMotor2] = threshold;
			motor[leftMotor3] = threshold;
			motor[rightMotor4] = threshold;
			motor[rightMotor5] = threshold;
			motor[rightMotor6] = threshold;
		}
		else if (abs(vexRT[Ch4]) > 63)
		{
			motor[leftMotor1] = (threshold + vexRT[Ch4]/2.5);
			motor[leftMotor2] = (threshold + vexRT[Ch4]/2.5);
			motor[leftMotor3] = (threshold + vexRT[Ch4]/2.5);
			motor[rightMotor4] = (threshold - vexRT[Ch4]/2.5);
			motor[rightMotor5] = (threshold - vexRT[Ch4]/2.5);
			motor[rightMotor6] = (threshold - vexRT[Ch4]/2.5);
		}
		//save driving mode
		if(SensorValue[armSensor] < 550)
		{
			if(abs(vexRT[Ch4]) <= 63)
			{
				motor[leftMotor1] = vexRT[Ch3]/1.5;
				motor[leftMotor2] = vexRT[Ch3]/1.5;
				motor[leftMotor3] = vexRT[Ch3]/1.5;
				motor[rightMotor4] = vexRT[Ch3]/1.5;
				motor[rightMotor5] = vexRT[Ch3]/1.5;
				motor[rightMotor6] = vexRT[Ch3]/1.5;
			}
			else if (abs(vexRT[Ch4]) > 63)
			{
				motor[leftMotor1] = (vexRT[Ch3]/1.5 + vexRT[Ch4]/3);
				motor[leftMotor2] = (vexRT[Ch3]/1.5 + vexRT[Ch4]/3);
				motor[leftMotor3] = (vexRT[Ch3]/1.5 + vexRT[Ch4]/3);
				motor[rightMotor4] = (vexRT[Ch3]/1.5 - vexRT[Ch4]/3);
				motor[rightMotor5] = (vexRT[Ch3]/1.5 - vexRT[Ch4]/3);
				motor[rightMotor6] = (vexRT[Ch3]/1.5 - vexRT[Ch4]/3);
			}
		}
		//precise control
		else if(vexRT[Btn8D] == 1)
		{
			if(abs(vexRT[Ch4]) <= 63)
			{
				motor[leftMotor1] = vexRT[Ch3]/2.5;
				motor[leftMotor2] = vexRT[Ch3]/2.5;
				motor[leftMotor3] = vexRT[Ch3]/2.5;
				motor[rightMotor4] = vexRT[Ch3]/2.5;
				motor[rightMotor5] = vexRT[Ch3]/2.5;
				motor[rightMotor6] = vexRT[Ch3]/2.5;
			}
			else if (abs(vexRT[Ch4]) > 63)
			{
				motor[leftMotor1] = (vexRT[Ch3]/2.5 + vexRT[Ch4]/4);
				motor[leftMotor2] = (vexRT[Ch3]/2.5 + vexRT[Ch4]/4);
				motor[leftMotor3] = (vexRT[Ch3]/2.5 + vexRT[Ch4]/4);
				motor[rightMotor4] = (vexRT[Ch3]/2.5 - vexRT[Ch4]/4);
				motor[rightMotor5] = (vexRT[Ch3]/2.5 - vexRT[Ch4]/4);
				motor[rightMotor6] = (vexRT[Ch3]/2.5 - vexRT[Ch4]/4);
			}
		}
		//six bar control.
		if(SensorValue[armSensor] > 289  && SensorValue[armSensor] < 2064 )
		{
			if(vexRT[Btn5U] == 1)
			{
				armUp();
			}
			else	if(vexRT[Btn5D] == 1)
			{
				armDown();
			}
			else
			{
				armStop();
			}
		}
		//goes up from the lowest position.
		else if(SensorValue[armSensor] > 2064)
   	{
   		if(vexRT[Btn5U] == 1)
   		{
   			armUp();
   		}
   		else
 			{
 				armStop();
   		}
   	}
    //goes down from the highest position
    else if(SensorValue[armSensor]< 289)
    {
 			if(vexRT[Btn5D] == 1)
 			{
 				motor[rightTower] = -127;
   			motor[leftTower] = -127;
   		}
   		else
   			{
   				armStop();
   			}
   		}
  	//lock

		//claw
   		while(vexRT[Btn6D] == 1)
   		{
   			motor[claw] = 40;
				wait1Msec(1);
				motor[claw] = 0;
				wait1Msec(1);
   		}
   		if(vexRT[Btn6U] == 1)
   		{
   			motor[claw] = 127;
   		}
   		else
   		{
   			motor[claw] = 0;
   		}

/*		//claw1
		if(vexRT[Btn8L] == 1)
		{
			motor[claw] = 30;
		}
		else if(vexRT[Btn6U] == 1)
		{
			motor[claw] = 127;
		}
		else if(vexRT[Btn6D] == 1)
		{
			motor[claw] = -127;
		}
		else
		{
			motor[claw] = 0;
		}

		//claw2
		if(vexRT[Btn8L] == 1)
		{
			holdClaw();
		}
		else if(vexRT[Btn6U] == 1)
		{
			motor[claw] = 127;
		}
		else if(vexRT[Btn6D] == 1)
		{
			motor[claw] = -127;
		}
		else
		{
			motor[claw] = 0;
		}

		//claw3
		if(vexRT[Btn6U] == 1)
		{
			motor[claw] = 127;
		}
		else if(vexRT[Btn6D] == 1)
		{
			motor[claw] = -127;
		}
		else
		{
			motor[claw] = 0;
		}

*/
	}
}
