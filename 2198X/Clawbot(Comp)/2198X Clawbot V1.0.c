#pragma config(Sensor, in1,    arm,            sensorPotentiometer)
#pragma config(Sensor, dgtl1,  leftWheels,     sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightWheels,    sensorQuadEncoder)
#pragma config(Motor,  port1,           leftMotor1,    tmotorVex393, openLoop)
#pragma config(Motor,  port2,           leftMotor3,    tmotorVex393, openLoop)
#pragma config(Motor,  port3,           rightMotor4,   tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port4,           rightMotor5,   tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port5,           rightMotor6,   tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port6,           claw,          tmotorVex393, openLoop)
#pragma config(Motor,  port7,           leftTower,     tmotorVex393, openLoop)
#pragma config(Motor,  port8,           rightTower,    tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port10,          leftMotor2,    tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
changelog: V1.0
*/
#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(105)

void forwardAuto(int distance)//distance in positive
{
	SensorValue[leftWheels] = 0;
	SensorValue[rightWheels] = 0;
	while(SensorValue[leftWheels] < distance || SensorValue[rightWheels] < distance)
	{
		if(SensorValue[leftWheels] > SensorValue[rightWheels])
		{
			motor[leftMotor1] = 90;
			motor[leftMotor2] = 90;
			motor[leftMotor3] = 90;
			motor[rightMotor4] = 90 + abs(SensorValue[leftWheels] - SensorValue[rightWheels]);
			motor[rightMotor5] = 90 + abs(SensorValue[leftWheels] - SensorValue[rightWheels]);
			motor[rightMotor6] = 90 + abs(SensorValue[leftWheels] - SensorValue[rightWheels]);
		}
		else if(SensorValue[leftWheels] < SensorValue[rightWheels])
		{
			motor[leftMotor1] = 90 + abs(SensorValue[leftWheels] - SensorValue[rightWheels]);
			motor[leftMotor2] = 90 + abs(SensorValue[leftWheels] - SensorValue[rightWheels]);
			motor[leftMotor3] = 90 + abs(SensorValue[leftWheels] - SensorValue[rightWheels]);
			motor[rightMotor4] = 90;
			motor[rightMotor5] = 90;
			motor[rightMotor6] = 90;
		}
		else if(SensorValue[leftWheels] == SensorValue[rightWheels])
		{
			motor[leftMotor1] = 90;
			motor[leftMotor2] = 90;
			motor[leftMotor3] = 90;
			motor[rightMotor4] = 90;
			motor[rightMotor5] = 90;
			motor[rightMotor6] = 90;
		}
	}
	SensorValue[leftWheels] = 0;
	SensorValue[rightWheels] = 0;
}

void backwardAuto(int distance)//distance in negative
{
	SensorValue[leftWheels] = 0;
	SensorValue[rightWheels] = 0;
	while(SensorValue[leftWheels] > distance || SensorValue[rightWheels] > distance)
	{
		if(SensorValue[leftWheels] > SensorValue[rightWheels])
		{
			motor[leftMotor1] = 90 + abs(SensorValue[leftWheels] - SensorValue[rightWheels]);
			motor[leftMotor2] = 90 + abs(SensorValue[leftWheels] - SensorValue[rightWheels]);
			motor[leftMotor3] = 90 + abs(SensorValue[leftWheels] - SensorValue[rightWheels]);
			motor[rightMotor4] = 90;
			motor[rightMotor5] = 90;
			motor[rightMotor6] = 90;
		}
		else if(SensorValue[leftWheels] < SensorValue[rightWheels])
		{
			motor[leftMotor1] = 90;
			motor[leftMotor2] = 90;
			motor[leftMotor3] = 90;
			motor[rightMotor4] = 90 + abs(SensorValue[leftWheels] - SensorValue[rightWheels]);
			motor[rightMotor5] = 90 + abs(SensorValue[leftWheels] - SensorValue[rightWheels]);
			motor[rightMotor6] = 90 + abs(SensorValue[leftWheels] - SensorValue[rightWheels]);
		}
		else if(SensorValue[leftWheels] == SensorValue[rightWheels])
		{
			motor[leftMotor1] = 90;
			motor[leftMotor2] = 90;
			motor[leftMotor3] = 90;
			motor[rightMotor4] = 90;
			motor[rightMotor5] = 90;
			motor[rightMotor6] = 90;
		}
	}
	SensorValue[leftWheels] = 0;
	SensorValue[rightWheels] = 0;
}

void stopMoving()
{
	motor[leftMotor1] = 0;
	motor[leftMotor2] = 0;
	motor[leftMotor3] = 0;
	motor[rightMotor4] = 0;
	motor[rightMotor5] = 0;
	motor[rightMotor6] = 0;
}

void holdClaw()
{
	while(time1[T2] == 0)
	{
		motor[claw] = 40;
		wait1Msec(50);
		motor[claw] = 0;
		wait1Msec(10);
		ClearTimer(T2);
	}
}

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}
task autonomous()
{
  // .....................................................................................
  // Insert user code here.
  // .....................................................................................

	AutonomousCodePlaceholderForTesting();  // Remove this function call once you have "real" code.
}
task usercontrol()
{
	while (true)
	{
		//driving system
		if(abs(vexRT[Ch4]) < 90)
		{
			motor[leftMotor1] = vexRT[Ch3];
			motor[leftMotor2] = vexRT[Ch3];
			motor[leftMotor3] = vexRT[Ch3];
			motor[rightMotor4] = vexRT[Ch3];
			motor[rightMotor5] = vexRT[Ch3];
			motor[rightMotor6] = vexRT[Ch3];
		}
		else if (abs(vexRT[Ch4]) > 90)
		{
			motor[leftMotor1] = (vexRT[Ch3] - vexRT[Ch4]/2);
			motor[leftMotor2] = (vexRT[Ch3] - vexRT[Ch4]/2);
			motor[leftMotor3] = (vexRT[Ch3] - vexRT[Ch4]/2);
			motor[rightMotor4] = (vexRT[Ch3] + vexRT[Ch4]/2);
			motor[rightMotor5] = (vexRT[Ch3] + vexRT[Ch4]/2);
			motor[rightMotor6] = (vexRT[Ch3] + vexRT[Ch4]/2);
		}



		//six bar control.
    if(SensorValue[arm] >1  && SensorValue[arm] <1 )
    {
   			if(vexRT[Btn5U] == 1)
   			{
   				motor[leftTower] = 127;
   				motor[rightTower] = 127;
   			}
   			else	if(vexRT[Btn5D] == 1)
   			{
   				motor[leftTower] = -127;
   				motor[rightTower] = -127;
   			}
   			else
   			{
   				motor[leftTower] = 0;
   				motor[rightTower] = 0;
   			}
   		}



	  //claw1
		if(vexRT[Btn8L] == 1)
			{
				motor[claw] = 30;
			}
		else if(vexRT[Btn6U] == 1)
			{
				motor[claw] = 127;
			}
		else if(vexRT[Btn6D] == 1)
			{
				motor[claw] = -127;
			}
		else
			{
				motor[claw] = 0;
			}

		//claw2
		if(vexRT[Btn8L] == 1)
		{
			holdClaw();
		}
		else if(vexRT[Btn6U] == 1)
			{
				motor[claw] = 127;
			}
		else if(vexRT[Btn6D] == 1)
			{
				motor[claw] = -127;
			}
		else
			{
				motor[claw] = 0;
			}

		//claw3
		if(vexRT[Btn6U] == 1)
			{
				motor[claw] = 127;
			}
		else if(vexRT[Btn6D] == 1)
			{
				motor[claw] = -127;
			}
		else
			{
				motor[claw] = 0;
			}


	}
}
