#pragma config(Sensor, in1,    arm1,           sensorPotentiometer)
#pragma config(Sensor, in2,    arm2,           sensorPotentiometer)
#pragma config(Sensor, dgtl1,  rightDrive,     sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightMobile,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  leftMobile,     sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  leftDrive,      sensorQuadEncoder)
#pragma config(Motor,  port1,           mobileRightupMotor, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port2,           mobileRightdnMotor, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port3,           coneClawMotor, tmotorVex393, openLoop)
#pragma config(Motor,  port4,           coneRightMotor, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port5,           rightDriveMotor, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port6,           mobileLeftMotor, tmotorVex393, openLoop)
#pragma config(Motor,  port7,           coneLeftMotor, tmotorVex393, openLoop)
#pragma config(Motor,  port8,           mobileClawMotor, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port9,           backLeftMotor, tmotorVex393, openLoop)
#pragma config(Motor,  port10,          frontLeftMotor, tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(105)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

//Tasks

void drive (int speed) {
		motor[frontLeftMotor] = speed;
    motor[backLeftMotor] = speed;
    motor[rightDriveMotor] = speed*0.87;

}

void rotate (int speed) {
		motor[frontLeftMotor] = speed;
    motor[backLeftMotor] = speed;
    motor[rightDriveMotor] = -speed*0.87;

}


void coneTower (int speed) {
		motor[coneRightMotor] = -speed;
    motor[coneLeftMotor]  = -speed;
}



void mobileGoal (int speed) {
		motor[mobileLeftMotor] = -speed;
    motor[mobileRightupMotor] = -speed;
   	motor[mobileRightdnMotor]= -speed;

}


void coneClaw(int speed) {
		motor[coneClawMotor] = -speed;
}

void mobileServo (int speed) {
		motor[mobileClawMotor] = speed;
}

void clearEncoder() {

		SensorValue[rightDrive] = 0;      // Set the encoder so that it starts counting at 0
    SensorValue[leftDrive]  = 0;      // Set the encoder so that it starts counting at 0

    SensorValue[rightMobile] = 0;      // Set the encoder so that it starts counting at 0
    SensorValue[leftMobile]  = 0;      // Set the encoder so that it starts counting at 0

}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

    // All activities that occur before the competition starts
    // Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
  // .....................................................................................
  // Insert user code here.
  // .....................................................................................

		clearEncoder();

    pre_auton();

    // Direct from starting position
    while(SensorValue[rightDrive] < 800)
    {
        drive(90);
				coneTower(127);
				coneClaw(-63);
				mobileServo(63);

    }

    clearEncoder();

    while(SensorValue[rightDrive] < 750)
    {
        drive(90);
				coneTower(0);
				coneClaw(-25);
				mobileServo(0);

    }

		drive(0);
		clearEncoder();

		while(SensorValue[rightMobile] < 1300) {
				mobileGoal(100);
		}

		mobileGoal(0);
		clearEncoder();

		while(SensorValue[rightDrive] > -550)
    {
        drive(-90);
				coneTower(60);
				coneClaw(-25);
				mobileServo(0);

    }

    clearEncoder();

    while(SensorValue[rightDrive] > -50)
    {
        drive(-90);
				coneTower(0);
				coneClaw(80);
				mobileServo(0);

    }

    clearEncoder();

    while(SensorValue[rightDrive] > -500)
    {
        drive(-90);
				coneTower(-127);
				coneClaw(0);
				mobileServo(0);

    }

    clearEncoder();

    while(SensorValue[rightDrive] > -400)
    {
        drive(-90);
				coneTower(-127);
				coneClaw(0);
				mobileServo(0);
    }

    clearEncoder();
    drive(0);
    coneTower(0);

    while(SensorValue[rightDrive] > -880)
    {
        rotate(90);

    }
    drive(0);
    clearEncoder();

    while(SensorValue[rightDrive] < 500)
    {
        drive(90);
				coneTower(0);
				coneClaw(0);
				mobileServo(0);
    }

		drive(0);
    clearEncoder();

    while(SensorValue[rightMobile] < 1000) {
				mobileGoal(100);
		}

		mobileGoal(0);
		clearEncoder();

		 while(SensorValue[rightDrive] > -1200)
    {
        drive(-90);
				coneTower(0);
				coneClaw(0);
				mobileServo(0);
    }

    drive(0);
		clearEncoder();

		/*
			//slow down motors to hold arm
        motor[coneRightMotor] = (-40);
    motor[coneLeftMotor]  = (-40);
    wait1Msec(250);


//    // drive forward until mobile goal
    while(SensorValue[rightDrive] < 1970)
    {
        motor[frontLeftMotor] = 127;
        motor[backLeftMotor] = 127;
        motor[rightDriveMotor] = 127;

        // open mobile goal holder
        motor[mobileClawMotor] = 95;
        wait1Msec(500);
    }
    motor[coneRightMotor] = (-75);
    motor[coneLeftMotor]  = (-75);

    driveStop();

//    //lift mobile goal lift
        while(SensorValue[rightMobile] > -1345)
    {

        motor[mobileLeftMotor] = -127;
        motor[mobileRightupMotor] = -127;
        motor[mobileRightdnMotor]= -127;
        motor[mobileClawMotor] = -50;
        motor[coneClawMotor] = -20;
        motor[coneLeftMotor] = 60;
        motor[coneRightMotor] = 60;
    }
		///Tower Back///
    		while(SensorValue[rightMobile] > -1450)
    {
    		motor[coneLeftMotor] = 60;
        motor[coneRightMotor] = 60;
		}

//    // drive backwards
        while(SensorValue[rightDrive] > -100)
    {

        motor[frontLeftMotor] = -120;
        motor[backLeftMotor] = -120;
        motor[rightDriveMotor] = -106;


////lift goal even more//
        if (SensorValue[rightMobile] > -2000)
        {
        motor[mobileLeftMotor] = -127;
        motor[mobileRightupMotor] = -127;
        motor[mobileRightdnMotor]= -127;
        motor[coneRightMotor] = (-110);
        motor[coneLeftMotor]  = (-110);

        }

        else {
        motor[mobileLeftMotor] = 0;
        motor[mobileRightupMotor] = 0;
        motor[mobileRightdnMotor]= 0;

    }
//// grip goal///
        motor[mobileClawMotor] = -60;

    }

    // stop and raise///
        motor[frontLeftMotor] = 0;
        motor[backLeftMotor] = 0;
        motor[rightDriveMotor] = 0;
        motor[coneRightMotor] = (127);
    motor[coneLeftMotor]  = (127);
    motor[coneClawMotor] = -127;

    motor[mobileLeftMotor] = 0;
    motor[mobileRightupMotor] = 0;
    motor[mobileRightdnMotor] = 0;


//    // rotate to score
    while(SensorValue[rightDrive] < 280)
    {
        motor[coneRightMotor] = (127);
    motor[coneLeftMotor]  = (127);
        motor[frontLeftMotor] = -127;
        motor[backLeftMotor] = -127;
        motor[rightDriveMotor] = 127;
    }


//    // forward over bar
      while(SensorValue[rightDrive] < 800)
    {

        motor[frontLeftMotor] = 127;
        motor[backLeftMotor] = 127;
        motor[rightDriveMotor] = 127;

        motor[coneRightMotor] = (127);
    motor[coneLeftMotor]  = (127);

        motor[mobileClawMotor] = 127;
    }

        motor[frontLeftMotor] = 0;
        motor[backLeftMotor] = 0;
        motor[rightDriveMotor] = 0;

//        // lift to dump goal
        while(SensorValue[rightMobile] > -2800)
    {

        motor[mobileLeftMotor] = -127;
        motor[mobileRightupMotor] = -127;
        motor[mobileRightdnMotor] = -127;
        motor[mobileClawMotor] = 127;

        }

    motor[mobileLeftMotor] = 0;
    motor[mobileRightupMotor] = 0;
    motor[mobileRightdnMotor] = 0;

    motor[coneLeftMotor] = 0;
    motor[coneRightMotor] = 0;

//  // drive backwards
  while(SensorValue[rightDrive] > 250)
    {

        motor[frontLeftMotor] = -127;
        motor[backLeftMotor] = -127;
        motor[rightDriveMotor] = -127;
        motor[mobileClawMotor] = 127;
    }

        motor[frontLeftMotor] = 0;
        motor[backLeftMotor] = 0;
        motor[rightDriveMotor] = 0;

        motor[mobileLeftMotor] = 0;
        motor[mobileRightupMotor] = 0;
        motor[mobileRightdnMotor] = 0;
}
*/
}


/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
    // User control code here, inside the loop

    SensorValue[rightDrive] = 0;      // Set the encoder so that it starts counting at 0
    SensorValue[leftDrive]  = 0;      // Set the encoder so that it starts counting at 0

    SensorValue[rightMobile] = 0;      // Set the encoder so that it starts counting at 0
    SensorValue[leftMobile]  = 0;      // Set the encoder so that it starts counting at 0

    while (true)
    {


    //Right side of the robot is controlled by the right joystick, Y-axis
    motor[rightDriveMotor] = vexRT[Ch2];
    //Left side of the robot is controlled by the left joystick, Y-axis
    motor[backLeftMotor] = vexRT[Ch3];
    motor[frontLeftMotor] = vexRT[Ch3];

        //motor[frontLeftMotor]  = (vexRT[Ch3] + vexRT[Ch4])/1;  // (y + x)/2
        //motor[backLeftMotor]  = (vexRT[Ch3] + vexRT[Ch4])/1; // (y + x)/2
        //motor[rightDriveMotor] = (vexRT[Ch3] - vexRT[Ch4])/1; // (y - x)/2

    // Control speeds from variable to make changes easier
    int mobileSpeed = 127;
    int towerSpeed = 127;
    int clawSpeed = 127;



      //Tower Cone Control
    // Slow dowm motors
    if(vexRT[Btn6D] == 1)
    {
      motor[coneRightMotor] = towerSpeed;
      motor[coneLeftMotor] = towerSpeed;
    }
    else if(vexRT[Btn6U] == 1)
    {
      motor[coneRightMotor] = (-1)*(towerSpeed);
      motor[coneLeftMotor] = (-1)*(towerSpeed);
    }
    else
    {
      motor[coneRightMotor] = 0;
      motor[coneLeftMotor] = 0;
    }

    //Mobile Goal Control

    // endcoder
    // + down
    // - up

    int rightInverse = (SensorValue[rightMobile])*-1;
    int leftInverse = (SensorValue[leftMobile])*-1;

   // int difference = ((SensorValue[rightMobile] - SensorValue[leftMobile])*(SensorValue[rightMobile] - SensorValue[leftMobile]))/3;
    int difference = 0;

    if(vexRT[Btn5D] == 1)
    {

   // if(SensorValue[rightMobile] < 200) {

    if(SensorValue[rightInverse] == SensorValue[leftInverse]) // If rightEncoder has counted the same amount as leftEncoder:
        {
            // Move Forward
        motor[mobileLeftMotor] = mobileSpeed;
        motor[mobileRightupMotor] = mobileSpeed;            // Left Motor is run at power level 80
        motor[mobileRightdnMotor] = mobileSpeed;
    }
        else if(SensorValue[rightInverse] > SensorValue[leftInverse])    // If rightEncoder has counted more encoder counts
        {
            // Turn slightly right
            motor[mobileLeftMotor] = mobileSpeed;
        motor[mobileRightupMotor] = mobileSpeed-difference;        // Left Motor is run at power level 80
         motor[mobileRightdnMotor] = mobileSpeed-difference;
        }
        else    // Only runs if leftEncoder has counted more encoder counts
        {
            // Turn slightly left
            motor[mobileLeftMotor] = mobileSpeed-difference;
            motor[mobileRightupMotor] = mobileSpeed;            // Left Motor is run at power level 60
            motor[mobileRightdnMotor] = mobileSpeed;
        }

    }

//    else {
 //       if(vexRT[Btn7D] == 1)
//    {
//        motor[mobileLeftMotor] = 127;
//      motor[mobileRightupMotor] = 127;
//      motor[mobileRightdnMotor] = 127;
 //     }
//  }
//  }

   else {
       if(vexRT[Btn5U] == 1)
   {
   //if(SensorValue[rightMobile] > -2200) {

   if(SensorValue[rightMobile] == SensorValue[leftMobile]) // If rightEncoder has counted the same amount as leftEncoder:
      {
            // Move Forward
        motor[mobileLeftMotor] = -1*mobileSpeed;
     motor[mobileRightupMotor] = -1*mobileSpeed;            // Left Motor is run at power level 80
     motor[mobileRightdnMotor] = -1*mobileSpeed;
      }
        else if(SensorValue[rightMobile] > SensorValue[leftMobile])    // If rightEncoder has counted more encoder counts
        {
            // Turn slightly right                           // Left Motor is run at power level 80
            motor[mobileLeftMotor] = -1*(mobileSpeed);
            motor[mobileRightupMotor] = -1*(mobileSpeed-difference);
            motor[mobileRightdnMotor] = -1*(mobileSpeed-difference);
        }
        else    // Only runs if leftEncoder has counted more encoder counts
        {
            // Turn slightly left
            motor[mobileLeftMotor] = -1*(mobileSpeed-difference);
        motor[mobileRightupMotor] = -1*(mobileSpeed);            // Left Motor is run at power level 60
        motor[mobileRightdnMotor] = -1*(mobileSpeed);
        }

    }

//    else {
//        if(vexRT[Btn7U] == 1)
 //   {
 //       motor[mobileLeftMotor] = -127;
 //     motor[mobileRightupMotor] = -127;
 //     motor[mobileRightdnMotor] = -127;
 //     }
 // }

 //   }
    else
    {
      motor[mobileLeftMotor] = 0;
      motor[mobileRightupMotor] = 0;
      motor[mobileRightdnMotor] = 0;
    }
   }

    if(vexRT[Btn7L] == 1)
    {
      motor[mobileLeftMotor] = clawSpeed;
    }
    if(vexRT[Btn7R] == 1)
    {
     motor[mobileRightupMotor] = clawSpeed;
     motor[mobileRightdnMotor] = clawSpeed;
    }

    //Claw Motor//


		 if(vexRT[Btn8L] == 1)
    {
      motor[coneClawMotor] = 30;
    }
    else if(vexRT[Btn8R] == 1)
    {
      motor[coneClawMotor] = (-1)*(30);
    }

    ///Mobile claw motor///
	 if(vexRT[Btn8D] == 1)
    {
      motor[mobileClawMotor] = 127;
    }
    else if(vexRT[Btn8U] == 1)
    {
      motor[mobileClawMotor] = (-1)*(127);
    }
    else
    {
      motor[mobileClawMotor] = -5;
      }

  }
}
