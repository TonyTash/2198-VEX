#pragma config(Sensor, in1,    lArmPot,        sensorPotentiometer)
#pragma config(Sensor, in2,    rArmPot,        sensorPotentiometer)
#pragma config(Sensor, in3,    lPivotPot,      sensorPotentiometer)
#pragma config(Sensor, in4,    rPivotPot,      sensorPotentiometer)
#pragma config(Motor,  port1,           lBackMotor,    tmotorVex393, openLoop)
#pragma config(Motor,  port2,           rFrontMotor,   tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port3,           rBackMotor,    tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port6,           rArmMotor,     tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port7,           lArmMotor,     tmotorVex393, openLoop)
#pragma config(Motor,  port8,           rPivot,        tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port9,           lPivot,        tmotorVex393, openLoop)
#pragma config(Motor,  port10,          lFrontMotor,   tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// 2198Y Drive Program
// Last Updated by Tony T

int lOffset = 220;
int rOffset = 0;
int lPOffset = 0;
int rPOffset = 350;
int pivotHold = 0;
int armMode = 0;
// 0 = user
// 1 = arm down
// 2 = arm half up
// 3 = scoring position


void forward()
{
	motor[lFrontMotor] = 127;
	motor[lBackMotor] = 127;
	motor[rFrontMotor] = 127;
	motor[rBackMotor] = 127;
}

void backward()
{
	motor[lFrontMotor] = -127;
	motor[lBackMotor] = -127;
	motor[rFrontMotor] = -115;
	motor[rBackMotor] = -115;
}

void rest()
{
	motor[lFrontMotor] = 0;
	motor[lBackMotor] = 0;
	motor[rFrontMotor] = 0;
	motor[rBackMotor] = 0;
}

void cw()
{
	motor[lFrontMotor] = 127;
	motor[lBackMotor] = 127;
	motor[rFrontMotor] = -127;
	motor[rBackMotor] = -127;
}

void ccw()
{
	motor[lFrontMotor] = -127;
	motor[lBackMotor] = -127;
	motor[rFrontMotor] = 127;
	motor[rBackMotor] = 127;
}

void armUp(int lArm, int rArm, int motorspeed)
{
	if (lArm == rArm)
	{
		motor[rArmMotor] = 127;
		motor[lArmMotor] = 127;
	}

	else if (lArm > rArm)
	{
		motor[rArmMotor] = 127;
		motor[lArmMotor] = (127 - motorspeed);
	}

	else if (lArm < rArm) {
		motor[rArmMotor] = (127 - motorspeed);
		motor[lArmMotor] = 127;
	}
}

void armDown(int lArm, int rArm, int motorspeed)
{
		if (lArm == rArm)
			{
				motor[rArmMotor] = -127;
				motor[lArmMotor] = -127;
			}

			else if (lArm > rArm)
			{
				motor[rArmMotor] = (-127 + motorspeed);
				motor[lArmMotor] = -127;
			}

			else if (lArm < rArm)
			{
				motor[rArmMotor] = -127;
				motor[lArmMotor] = (-127 + motorspeed);
			}
}

void pivotUp(int lPivotSensor, int rPivotSensor, int pivotspeed)
{

			motor[lPivot] = 127;
			motor[rPivot] = 127;

			//if (lPivotSensor == rPivotSensor)
			//{
			//	motor[lPivot] = 90;
			//	motor[rPivot] = 90;
			//}

			//else if (lPivotSensor > rPivotSensor)
			//{
			//	motor[rPivot] = 90;
			//	motor[lPivot] = (90 - pivotspeed);
			//}

			//else if (lPivotSensor < rPivotSensor) {
			//	motor[rPivot] = (90 - pivotspeed);
			//	motor[lPivot] = 90;
			//}

}

void pivotDown(int lPivotSensor, int rPivotSensor, int pivotspeed)
{

			motor[lPivot] = -127;
			motor[rPivot] = -127;

	//if (lPivotSensor == rPivotSensor)
	//		{
	//			motor[rPivot] = -90;
	//			motor[lPivot] = -90;
	//		}

	//		else if (lPivotSensor > rPivotSensor)
	//		{
	//			motor[rPivot] = (-90 + pivotspeed);
	//			motor[lPivot] = -90;
	//		}

	//		else if (lPivotSensor < rPivotSensor)
	//		{
	//			motor[rPivot] = -90;
	//			motor[lPivot] = (-90 + pivotspeed);
	//		}
}

void armHold () {

	motor[lArmMotor] = 0;
	motor[rArmMotor] = 0;

}

void pivotRest () {

	motor[lPivot] = 0;
	motor[rPivot] = 0;

}


task main()
{
	// turn shovel down
	int lPivotSensor = (4096 - (SensorValue[lPivotPot] + lPOffset)); // LARM MINUS THE OFFSER (TO CALIBRATE)
	int rPivotSensor = (SensorValue[rPivotPot] - rPOffset); // ALSO NEGATES THE POTENTIOMETER

	while (rPivotSensor < 2450)
	{
		motor[lPivot] = -127;
		motor[rPivot] = -127;
		lPivotSensor = (4096 - (SensorValue[lPivotPot] - lPOffset)); // LARM MINUS THE OFFSER (TO CALIBRATE)
		rPivotSensor = (SensorValue[rPivotPot] - rPOffset); // ALSO NEGATES THE POTENTIOMETER
	}
	motor[rPivot] = 0;
	motor[lPivot] = 0;

	ClearTimer(T1);
	// move forward, pick up star

	while (time1[T1] < 600)
	{
		forward();
	}
	rest();

	// initialize arm

	int lArm = (SensorValue[lArmPot] + lOffset); // LARM MINUS THE OFFSER (TO CALIBRATE)
	int rArm = (SensorValue[rArmPot] + rOffset); // ALSO NEGATES THE POTENTIOMETER

	// raise arm
		motor[lPivot] = 55;
		motor[rPivot] = 55;

	while (lArm < 1200)
	{
		motor[lArmMotor] = 127;
		motor[rArmMotor] = 127;
		lArm = (SensorValue[lArmPot] + lOffset); // LARM MINUS THE OFFSER (TO CALIBRATE)
		rArm = (SensorValue[rArmPot] + rOffset); // ALSO NEGATES THE POTENTIOMETER
	}
	motor[lArmMotor] = 0;
	motor[rArmMotor] = 0;
	wait1Msec(250);
	motor[lPivot] = -32;
	motor[rPivot] = -32;
	wait1Msec(60);
	motor[lPivot] = 15;
	motor[rPivot] = 15;


	clearTimer(T4);

	// turn and goto fence

	ClearTimer(T2);

	while (time1[T2] < 360)
	{
		ccw();
	}
	rest();

	wait1Msec(100);

	ClearTimer(T3);

	while (time1[T3] < 2500)
	{
		backward();
	}

	rest();

	while (lArm < 2000)
	{
		motor[lArmMotor] = 127;
		motor[rArmMotor] = 127;
		lArm = (SensorValue[lArmPot] + lOffset); // LARM MINUS THE OFFSER (TO CALIBRATE)
		rArm = (SensorValue[rArmPot] + rOffset); // ALSO NEGATES THE POTENTIOMETER
	}

	ClearTimer(T1);
	while (time1[T1] < 500)
	{
		motor[lPivot] = 127;
		motor[rPivot] = 127;
	}

	motor[lArmMotor] = 0;
	motor[rArmMotor] = 0;
	motor[lPivot] = 0;
	motor[rPivot] = 0;



}
