#pragma config(Sensor, in1,    lArmPot,        sensorPotentiometer)
#pragma config(Sensor, in2,    rArmPot,        sensorPotentiometer)
#pragma config(Sensor, in3,    lPivotPot,      sensorPotentiometer)
#pragma config(Sensor, in4,    rPivotPot,      sensorPotentiometer)
#pragma config(Motor,  port1,           lBackMotor,    tmotorVex393, openLoop)
#pragma config(Motor,  port2,           rFrontMotor,   tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port3,           rBackMotor,    tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port6,           lArmMotor,     tmotorVex393, openLoop)
#pragma config(Motor,  port7,           rArmMotor,     tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port8,           lPivot,        tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port9,           rPivot,        tmotorVex393, openLoop)
#pragma config(Motor,  port10,          lFrontMotor,   tmotorVex393, openLoop)

//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// 2198Y Drive Program
// Last Updated by Tony T on 2016-11-08

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(105)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!



//////////////////////////// PRE- AUTONOMOUS ///////////////////////////////////////

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

//////////////////////////// AUTONOMOUS ////////////////////////////////////////////

task autonomous()
{

	AutonomousCodePlaceholderForTesting();
}

/////////////////////////// USER CONTROL ///////////////////////////////////////////

task usercontrol()
{
	// User control code here, inside the loop

	while (true)
	{

	  // Assign sensor inputs to variables
		int lArm = (SensorValue[lArmPot] + lOffset); // LARM MINUS THE OFFSER (TO CALIBRATE)
  	int rArm = (SensorValue[rArmPot] + rOffset); // ALSO NEGATES THE POTENTIOMETER

   	int motorspeed = sqrt( (lArm - rArm)*(lArm - rArm) ); // Create variable to change motor speed based on how different the readings are


    //Right side of the robot is controlled by the right joystick, Y-axis
    motor[rFrontMotor] = vexRT[Ch2];
    motor[rBackMotor]  = vexRT[Ch2];
    //Left side of the robot is controlled by the left joystick, Y-axis
    motor[lFrontMotor] = vexRT[Ch3];
    motor[lBackMotor]  = vexRT[Ch3];

  //  if (vexRT[Btn7R])
  //{
  //	motor[rArmMotor] = 127;
  //}
  //if (vexRT[Btn7U])
  //{
  //	motor[lArmMotor] = 127;
  //}
  //if (vexRT[Btn7L])
  //{
  //	motor[lArmMotor] = 127;
  //}

	if (vexRT[Btn6D] == 1)
	{
		if (lArm == rArm)
			{
			motor[rArmMotor] = 127;
			motor[lArmMotor] = 127;
		}

		else if (lArm > rArm)
			{
			motor[rArmMotor] = 127;
			motor[lArmMotor] = (127 - motorspeed);
		}

		else if (lArm < rArm) {
			motor[rArmMotor] = (127 - motorspeed);
			motor[lArmMotor] = 127;
		}
	}

	else if (vexRT[Btn6U] == 1)
	{
		if (lArm == rArm)
			{
			motor[rArmMotor] = -127;
			motor[lArmMotor] = -127;
		}

		else if (lArm > rArm)
			{
			motor[rArmMotor] = (-127 + motorspeed);
			motor[lArmMotor] = -127;
		}

		else if (lArm < rArm)
			{
			motor[rArmMotor] = -127;
			motor[lArmMotor] = (-127 + motorspeed);
		}
	}

   else
     {
	   motor[lArmMotor] = 0;
	   motor[rArmMotor] = 0;
   }


    // Pivot System

  	if (vexRT[Btn5U] == 1)
  	{
  	motor[lPivot] = 127;
  	motor[rPivot] = 127;
  	}

  	else if (vexRT[Btn5D] == 1)
  	{
		motor[rPivot] = -127;
		motor[lPivot] = -127;
		}

		else
		{
		motor[lPivot] = 0;
		motor[rPivot] = 0;
		}
	}
}
