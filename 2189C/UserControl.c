#pragma config(Sensor, in2,    rArmPot,        sensorPotentiometer)
#pragma config(Sensor, in3,    lArmPot,        sensorPotentiometer)
#pragma config(Motor,  port2,           rFrontMotor,   tmotorVex393, openLoop)
#pragma config(Motor,  port3,           rBackMotor,    tmotorVex393, openLoop)
#pragma config(Motor,  port4,           lBackMotor,    tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port5,           lFrontMotor,   tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port6,           rArmMotor,     tmotorVex393, openLoop)
#pragma config(Motor,  port7,           lArmMotor,     tmotorVex393, openLoop)
#pragma config(Motor,  port8,           lPivot,        tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port9,           rPivot,        tmotorVex393, openLoop)


//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// 2198Y Drive Program
// Last Updated by Tony T

	int lOffset = 1640;
	int rOffset = 1845;
	int lPOffset = 0;
	int rPOffset = 0;
	int pivotHold = 0;
	int armMode = 0;
	// 0 = user
	// 1 = arm down
	// 2 = arm half up
	// 3 = scoring position

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(105)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!



//////////////////////////// PRE- AUTONOMOUS ///////////////////////////////////////

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

//////////////////////////// AUTONOMOUS ////////////////////////////////////////////

task autonomous()
{
// na
}

task usercontrol()
{
	// User control code here, inside the loop

	while (true)
	{

	  // Assign sensor inputs to variables
		int rArm = (SensorValue[lArmPot] - lOffset); // LARM MINUS THE OFFSER (TO CALIBRATE)
  	int lArm = (SensorValue[rArmPot] - rOffset); // ALSO NEGATES THE POTENTIOMETER


   	int motorspeed = sqrt( (lArm - rArm)*(lArm - rArm) ); // Create variable to change motor speed based on how different the readings are


    //Right side of the robot is controlled by the right joystick, Y-axis
    motor[rFrontMotor] = vexRT[Ch2];
    motor[rBackMotor]  = vexRT[Ch2];
    //Left side of the robot is controlled by the left joystick, Y-axis
    motor[lFrontMotor] = vexRT[Ch3];
    motor[lBackMotor]  = vexRT[Ch3];

  //  if (vexRT[Btn7R])
  //{
  //	motor[rArmMotor] = 127;
  //}
  //if (vexRT[Btn7U])
  //{
  //	motor[lArmMotor] = 127;
  //}
  //if (vexRT[Btn7L])
  //{
  //	motor[lArmMotor] = 127;
  //}










	// ARM PROGRAM

	if (vexRT[Btn6U] == 1)
	{
		if (lArm == rArm)
			{
			motor[rArmMotor] = 127;
			motor[lArmMotor] = 127;
		}

		else if (lArm > rArm)
			{
			motor[rArmMotor] = 127;
			motor[lArmMotor] = (127 - motorspeed/2);
		}

		else if (lArm < rArm) {
			motor[rArmMotor] = (127 - motorspeed/2);
			motor[lArmMotor] = 127;
		}
	}

	else if (vexRT[Btn6D] == 1)
	{
		if (lArm == rArm)
			{
			motor[rArmMotor] = -127;
			motor[lArmMotor] = -127;
		}

		else if (lArm > rArm)
			{
			motor[rArmMotor] = (-127 + motorspeed/2);
			motor[lArmMotor] = -127;
		}

		else if (lArm < rArm)
			{
			motor[rArmMotor] = -127;
			motor[lArmMotor] = (-127 + motorspeed/2);
		}
	}

   else
     {
	   motor[lArmMotor] = 0;
	   motor[rArmMotor] = 0;
   }

   if (vexRT[Btn7U] == 1)
   {
     pivotHold = 0;
  }
  if (vexRT[Btn7D] == 1)
   {
     pivotHold = 0;
  }


    // MACRO System





  	if (vexRT[Btn5U] == 1)
  	{
  	motor[lPivot] = 127;
  	motor[rPivot] = 127;
  	}

  	else if (vexRT[Btn5D] == 1)
  	{
		motor[rPivot] = -127;
		motor[lPivot] = -127;
		}

		else if (pivotHold == 0)
    {
    motor[lPivot] = 0;
  	motor[rPivot] = 0;
  	}


		else
		{
		motor[lPivot] = 30;
		motor[rPivot] = 30;
		}
	}
}

/* Changelogs

v1.0.0 		2016-11-01		Created 4 motor drive program
v1.0.1		2016-11-01		Reversed right motors
v2.0.0		2016-11-02		Started arm motor program
v2.0.1		2016-11-02		Added pragma config for arms
v2.1.0		2016-11-02		Added code for arm to go up based on buttons
v2.1.1		2016-11-03		Added potentiometers into pragma config
v3.0.0		2016-11-04		Potentiometer code active
v3.1.0		2016-11-07		Changed joystick buttons
v3.2.0		2016-11-07		Added variables for offset, included potentiometer readings into loop
v3.2.x		2016-11-07		Attempt to fix potentiometers
v4.x.x		2016-11-07		New potentiometer code attempts
v5.0.0		2016-11-07		Working potentiometer code
v5.1.0		2016-11-08		changed ports for base
v5.2.0		2016-11-08		Pivot (without potentiometers) added
v6.0.0		2016-11-13		Switched code to competition template
v6.1.x		2016-11-13		Autonomous timings calculate
v6.2.x		2016-11-13		Autonomous strategy changes
v7.0.x		2016-11-14		Macro key programming

*/
